* With synchronized keyword, you have to leave the lock, once you exist a synchronized method or block, there is no 
way you can take the lock to other method. java.util.concurrent.locks.ReentrantLock solves this problem by providing 
control for acquiring and releasing lock, which means you can acquire lock in method A and can release in method B, 
if they both needs to be locked in same object lock. Though this could be risky as compiler will neither check nor warn 
you about any accidental leak of locks. Which means, this can potentially block other threads, which are waiting for 
same lock.

* synchronized keyword in internally implemented using two byte code instructions MonitorEnter and MonitorExit, this is
 generated by compiler. Compiler also ensures that there must be a MonitorExit for every MonitorEnter in different code
 path e.g. normal execution and abrupt execution, because of Exception

* synchronized keyword doesn't allow separate locks for reading and writing. as we know that multiple thread can read 
without affecting thread-safety of class, synchronized keyword suffer performance due to contention in case of multiple 
reader and one or few writer.

* if one thread is waiting for lock then there is no way to time out or to interrupt the thread, thread can wait indefinitely for lock.

