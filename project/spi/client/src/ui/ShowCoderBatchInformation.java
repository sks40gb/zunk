package ui;

import client.ClientTask;
import client.TaskGetCoderBatchInfo;
import client.TaskISOSampling;
import client.TaskSendProjectParameters;
import common.Log;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.Font;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JCheckBox;
import javax.swing.JDialog;
import javax.swing.JPanel;
import javax.swing.JTable;
import javax.swing.border.LineBorder;
import javax.swing.table.AbstractTableModel;


/** 
 * Dialog Window to Show Coder Batch Information
 * @author  anurag
 */
public class ShowCoderBatchInformation extends JDialog
{
   private JDialog parent = null;
   CheckBoxTableModel model = null;
   public int userId = 0; 
   private ResultSet results = null;
   
   private int volume_id = 0;
   private int project_id = 0;
   private int lotsize = 0;
   private int documentCount = 0;
   private int documentNumberCount = 0;
   private int sample_size = 0;
   private Map usersMap = null;
   private int accept_number = 0;
   private int reject_number = 0;
   private int error_count = 0;
   private String error_status = null;
   private String sampling_type = null;
   private String samplingMethod = null;
   private String inspectionType = null;
   private String accuracy = null;
   private String aql = null;
   private StringBuffer fieldCounted = new StringBuffer();
   private StringBuffer fieldShown = new StringBuffer();
   private StringBuffer usersString = new StringBuffer(); 
   private StringBuffer userNameString = new StringBuffer();
   
   
   /**
     * Creates new form Show Coder Batch Information.
     * @param parent the frame in which to place this screen
     */
   public ShowCoderBatchInformation(JDialog parent,int volumeid,int projectid)
   {      
      this.parent = parent;
      this.volume_id = volumeid;
      this.project_id = projectid;
      initComponents(this.volume_id,this.project_id);
   }

   /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
   private void initComponents(int volumeId,int projectid)
   {
      coderPanel = new javax.swing.JPanel();
      fieldPanel = new javax.swing.JPanel();
      coderPane = new javax.swing.JScrollPane();
      fieldPane = new javax.swing.JScrollPane();
      coderBatchTable = new javax.swing.JTable();
      fieldTable = new javax.swing.JTable();
      bottomPane = new javax.swing.JPanel();
      headerPane = new javax.swing.JPanel();
      rightheaderPane = new javax.swing.JPanel();
      coderButtonPanel = new javax.swing.JPanel();
      fieldButtonPanel = new javax.swing.JPanel();
      proceedButton = new javax.swing.JButton();
      samplingButton = new javax.swing.JButton();
      leftContentPanel = new JPanel(new BorderLayout());
      rightContentPanel = new JPanel(new BorderLayout());
      contentPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
      selectAllCoderCheckBox = new JCheckBox("Select All Coder/Batch");
      selectAllFieldCheckBox = new JCheckBox("Select All Fields");

      addWindowListener(new java.awt.event.WindowAdapter()
        {
           public void windowClosing(java.awt.event.WindowEvent evt)
           {
              windowCloseActionPerformed();
           }
        });

      extractCoderBatchInfo(volumeId);
      usersMap = new HashMap();
      //getProjectFields(projectid);
      headerLabel = new javax.swing.JLabel("Select Coder/Batch :");
      headerLabel.setFont(new Font("ARIAL", Font.BOLD, 12));
      fieldLabel = new javax.swing.JLabel("Output fields :");
      fieldLabel.setFont(new Font("ARIAL", Font.BOLD, 12));
      this.setSize(500,550);
      this.setLocationRelativeTo(parent);
      this.setTitle("Coders/Batch List");

      headerPane.setLayout(new FlowLayout());
      headerPane.add(headerLabel);
      
      rightheaderPane.setLayout(new FlowLayout());
      rightheaderPane.add(fieldLabel);
      
      coderPanel.setLayout(new java.awt.BorderLayout());

      coderPanel.setBorder(new javax.swing.border.SoftBevelBorder(javax.swing.border.BevelBorder.RAISED));

      coderPane.setViewportView(coderBatchTable);
            
      coderPanel.add(coderPane, java.awt.BorderLayout.CENTER);

      leftContentPanel.add(coderPanel, java.awt.BorderLayout.CENTER);
      
      fieldPanel.setLayout(new java.awt.BorderLayout());

      fieldPanel.setBorder(new javax.swing.border.SoftBevelBorder(javax.swing.border.BevelBorder.RAISED));

      fieldPane.setViewportView(fieldTable);
      fieldPanel.add(fieldPane,BorderLayout.CENTER);
      rightContentPanel.add(rightheaderPane,BorderLayout.NORTH);
      rightContentPanel.add(fieldPanel,java.awt.BorderLayout.CENTER);

      coderButtonPanel.setLayout(new java.awt.GridLayout(1, 0, 20, 0));
      
      proceedButton.setText("Proceed Sampling");
      proceedButton.setMnemonic('P');
      proceedButton.setEnabled(true);
      proceedButton.addActionListener(new java.awt.event.ActionListener()
      {
        public void actionPerformed(java.awt.event.ActionEvent evt)
        {
                proceedSampling();
                //QAGroupAssignmentPage qa_assignment_page = new QAGroupAssignmentPage();
                //qa_assignment_page.setVisible(true);
                //parent.setVisible(true);
                
        }
      });
      
      selectAllCoderCheckBox.setSelected(true);
      selectAllCoderCheckBox.addActionListener(new java.awt.event.ActionListener()
      {
        public void actionPerformed(java.awt.event.ActionEvent evt)
        {          
           selectAllCheckBoxes(coderBatchTable,selectAllCoderCheckBox);
        }
      });
      
      coderButtonPanel.add(selectAllCoderCheckBox);
      coderButtonPanel.add(proceedButton);

      bottomPane.add(coderButtonPanel);    
      
      selectAllFieldCheckBox.addActionListener(new java.awt.event.ActionListener()
      {
        public void actionPerformed(java.awt.event.ActionEvent evt)
        {          
           selectAllCheckBoxes(fieldTable,selectAllFieldCheckBox);
        }
      });
      fieldButtonPanel.add(selectAllFieldCheckBox);
      fieldButtonPanel.add(samplingButton);
      fieldButtonPanel.setLayout(new java.awt.GridLayout(1,0,20,0));
      rightContentPanel.add(fieldButtonPanel,BorderLayout.SOUTH);
      
      leftContentPanel.setBorder(new LineBorder(Color.BLACK));
      rightContentPanel.setBorder(new LineBorder(Color.BLACK));
      leftContentPanel.add(headerPane, java.awt.BorderLayout.NORTH);
      leftContentPanel.add(bottomPane, java.awt.BorderLayout.SOUTH);
      
      contentPanel.add(leftContentPanel);
      add(contentPanel);

   }

   //Action to be handled for close button action.

   private void windowCloseActionPerformed()
   {
      setVisible(false);
      this.parent.setVisible(true);
   }
     
   private void proceedSampling()
   {           
      int codersCount = coderBatchTable.getRowCount();      
      for(int i = 0 ; i < codersCount ; i++){
         boolean isChecked = (Boolean)coderBatchTable.getModel().getValueAt(i,0);
         if(isChecked){                        
            if(i != 0 && usersString.length() != 0){
               usersString.append(",");
            }
            
            if(i != 0 && userNameString.length() != 0) {
                userNameString.append(",");
            }
            usersString.append(getUsersMap().get(coderBatchTable.getModel().getValueAt(i,1)).toString());
            userNameString.append(coderBatchTable.getModel().getValueAt(i,1).toString());
         }
      }           
      sendProjectParameters();
      this.setVisible(false);
      parent.setVisible(false);
   }
  
   private void selectAllCheckBoxes(JTable jTableObj,JCheckBox jcheckBoxObj){
      int count = jTableObj.getRowCount();
      for(int i = 0 ; i < count ; i++){
         jTableObj.getModel().setValueAt(new Boolean(jcheckBoxObj.isSelected()),i ,0);
      } 
   }
   
   /**
     * Perform page initialization.  Subclasses must override this to provide any
     * required page-dependent initialization.
     * Displays the list in a table model.
     */

   protected void extractCoderBatchInfo(int volumeID)
   {
      try {         
         final ClientTask taskDisplay = new TaskGetCoderBatchInfo(volumeID);
         taskDisplay.setCallback(new Runnable()
                {
                   public void run()
                    {
                        try {
                           results = (java.sql.ResultSet) taskDisplay.getResult();                  
                           model = new CheckBoxTableModel(results, new String[]{"","Coders", "Checkers", "Batch"});                           
                           coderBatchTable.setModel(model);
                           coderBatchTable.getColumnModel().getColumn(0).setMaxWidth(20);
                           selectAllCheckBoxes(coderBatchTable,selectAllCoderCheckBox);
                           setUsersMap(model.getCodersInfoInMap());
                        } catch (SQLException ex) {
                           Logger.getLogger(ShowCoderBatchInformation.class.getName()).log(Level.SEVERE, null, ex);
                        }
                    }
                 });
         taskDisplay.enqueue(this);
      } catch (Throwable th) {
         Log.quit(th);
      }
   }   
   
   public void setProjectParameters(int documentNumberCount,int lotsize,String inspectionType,String aql,String samplingMethod,String samplingType,String accuracy,StringBuffer fieldCounted,StringBuffer fieldShown){
      this.documentNumberCount = documentNumberCount;
      this.lotsize = lotsize;
      this.samplingMethod = samplingMethod;
      this.sampling_type = samplingType;
      this.inspectionType = inspectionType;
      this.aql =aql;
      this.accuracy = accuracy;
      this.fieldCounted = fieldCounted;
      this.fieldShown = fieldShown;
   }
  
    private void sendProjectParameters(){
      try {
              final ClientTask task = new TaskSendProjectParameters(volume_id,lotsize,inspectionType,aql,project_id,samplingMethod,sampling_type,accuracy);

              task.setCallback(new Runnable()
              {
                 public void run()
                 {
                  try {
                       String[] resultArray = (String[])task.getResult();                                      
                       setSamplingParameters(resultArray);
                     } catch (Exception ex) {
                        ex.printStackTrace();                        
                     }
                    }
              });
              task.enqueue(this);                            
          }catch (Exception exception) {
               exception.printStackTrace();
            }
   }
 
   private void setSamplingParameters(String[] resultArray){
       
       if(null != resultArray[0] && !resultArray[0].isEmpty()) {
           sample_size = Integer.parseInt(resultArray[0]);
       }
       
       if(null != resultArray[1] && !resultArray[1].isEmpty()) {
           accept_number = Integer.parseInt(resultArray[1]);
       }
       
       if(null != resultArray[2] && !resultArray[2].isEmpty()) {
           reject_number = Integer.parseInt(resultArray[2]);
       }
       
       if(null != resultArray[3] && !resultArray[3].isEmpty()) {
           error_count = Integer.parseInt(resultArray[3]);
       }
     
     //debug only
     System.out.println("values ==============>>"+sample_size+","+accept_number+","+reject_number+","+error_count);
          
     int sample_document_size = 0;
     if(sampling_type.equalsIgnoreCase("Field Sampling")){
       sample_document_size = documentNumberCount/sample_size;
     }else{
       sample_document_size = documentNumberCount;
     }    
     
     final TaskISOSampling task = new TaskISOSampling(volume_id,project_id,sample_document_size,usersString.toString(),fieldCounted.toString());   
     task.setCallback(new Runnable()
     {
        public void run()
        {
         try {
              //setDocumentCount(Integer.parseInt(task.getResult().toString()));              
              
             } catch (Exception ex) {
               ex.printStackTrace();                        
            }
            ((QAVolumeSelectionDialog)((ProjectParameterWindow)parent).parent).checkCount(getDocumentCount(),userNameString.toString(),fieldShown.toString()); 
           }
     });
     task.enqueue(this);       
   }

   public int getDocumentCount()
   {
      return documentCount;
   }

   public void setDocumentCount(int documentCount)
   {
      this.documentCount = documentCount;
   }

   public Map getUsersMap()
   {
      return usersMap;
   }

   public void setUsersMap(Map usersMap)
   {
      this.usersMap = usersMap;
   }
   
   
      
   // Variables declaration -       

   private javax.swing.JPanel bottomPane;
   private javax.swing.JPanel headerPane;
   private javax.swing.JPanel rightheaderPane;
   private javax.swing.JLabel headerLabel;
   private javax.swing.JLabel fieldLabel;
   private javax.swing.JButton proceedButton;
   private javax.swing.JButton samplingButton;
   private javax.swing.JPanel coderButtonPanel;
   private javax.swing.JPanel coderPanel;
   private javax.swing.JPanel fieldButtonPanel;
   private javax.swing.JPanel fieldPanel;
   private javax.swing.JScrollPane coderPane;
   private javax.swing.JScrollPane fieldPane;
   private javax.swing.JTable coderBatchTable;
   private javax.swing.JTable fieldTable;
   private javax.swing.JPanel contentPanel;
   private javax.swing.JPanel leftContentPanel;
   private javax.swing.JPanel rightContentPanel;
   private JCheckBox selectAllCoderCheckBox;
   private JCheckBox selectAllFieldCheckBox;
   // End of variables declaration                   

}
class CheckBoxTableModel extends AbstractTableModel {
        private ResultSet resultSet =  null;      
        private String[] columnNames = null;
        private Object[][] data;       
        Map coderMap = new HashMap();
        public CheckBoxTableModel(ResultSet results, String[] headings) throws SQLException 
        {
           this.resultSet = results;
           this.columnNames = headings;
           int count = 0;
           while(results.next()){
              count++;
           }
           data = new Object[count][4];
           getData(results,count);
        }
             
        private Object[][] getData(ResultSet resultSet,int count)
        {       
          try{
           for(int i = 0; resultSet.previous(); i++)
           {            
             data[i][0] = new Boolean(resultSet.getString(1));
             if(this.columnNames.length < 4){
                data[i][1] = i + 1 + "";
                data[i][2] = resultSet.getString(3);
             }else{
                 String[] coderInfo = resultSet.getString(2).split(",");
                 setCodersInfoInMap(coderInfo);                 
                 data[i][1] = coderInfo[0];
                 data[i][2] = resultSet.getString(3);
                 data[i][3] = resultSet.getString(4);               
             }            
           }
          }catch(Exception e){e.printStackTrace();}
          
          return data;
        }
        
        public void setCodersInfoInMap(String[] coderInfo){           
           coderMap.put(coderInfo[0],coderInfo[1]);
        }
        
        public Map getCodersInfoInMap(){
           return coderMap;
        }
        
        public int getColumnCount() {
            return columnNames.length;
        }

        public int getRowCount() {
            return data.length;
        }

        public String getColumnName(int col) {
            return columnNames[col];
        }

        public Object getValueAt(int row, int col) {
            return data[row][col];
        }

         public ResultSet getResultSet()
         {
            return resultSet;
         }

         public void setResultSet(ResultSet resultSet)
         {
            this.resultSet = resultSet;
         }

        
        /*
         * JTable uses this method to determine the default renderer/
         * editor for each cell.  If we didn't implement this method,
         * then the last column would contain text ("true"/"false"),
         * rather than a check box.
         */
        public Class getColumnClass(int c) {
            return getValueAt(0, c).getClass();
        }
        
        public boolean isCellEditable(int row, int col) {
           if(col > 0){
              return false;
           }
            return true;
        }

        public void setValueAt(Object value, int row, int col) {
            data[row][col] = value;
            fireTableCellUpdated(row, col);
        }   
    }


