/* $Header: /home/common/cvsarea/ibase/dia/src/beans/LTextButton.java,v 1.30.2.6 2006/04/27 17:00:02 nancy Exp $ */
/*
 * LTextButton.java
 *
 * Created on July 21, 2003, 8:58 AM
 */
package beans;

import beans.TextDialog;
import client.ClientTask;
import client.TaskSelectFieldDescription;
import com.lexpar.util.Log;
import common.CodingData;
import java.awt.Color;
import java.awt.Component;
import java.util.StringTokenizer;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.event.KeyEvent;
import javax.swing.JCheckBox;
import javax.swing.JOptionPane;
import javax.swing.JTextField;
import javax.swing.text.Document;

/**
 * A panel containing a <code>JTextField</code> with a button that can be
 * pressed to invoke <code>beans.TextDialog</code> to enter large-volume text.
 * @author  nancy
 */
public class LTextButton extends javax.swing.JPanel implements LField {

    /** cached value of column width */
    public int lColumnWidth = 0;
    private String text = "Text Field";
    private String mask = "";
    private String validChars = "";
    private String invalidChars = "";
    private int columns = 0;
    private int maximumColumns = 0;
    private int projectId = 0;
    private String fieldName = "";
    private CodingData codingData;
    private String whichStatus;
    private static CodingData codingData_F6;
    //FocusText focusText = new FocusText();
    TextDialog select = null;

    /**
     * Constructs a new LTextButton initialized with the specified text
     * and maximum length.
     *
     * @param text the text to be displayed, or null
     * @param columns the maximum length of the text
     */
    public LTextButton(String text, int columns, String mask, String validChars, String invalidChars, int projectId,
            String fieldName, CodingData codingData, String whichStatus) {
        this.text = text;
        this.mask = mask;
        this.validChars = validChars;
        this.invalidChars = invalidChars;
        this.columns = columns;
        this.projectId = projectId;
        this.fieldName = fieldName;
        this.codingData = codingData;
        this.whichStatus = whichStatus;
        initComponents();
        setColumns(columns);
        maximumColumns = columns;
        button.setFocusable(false);
    }

    /**
     * Constructs a new LTextButton initialized with the specified text
     * and with no maximum length. The number of columns is 0.
     *
     * @param text the text to be displayed, or null
     */
    public LTextButton(String text, String mask, String validChars, String invalidChars) {
        this(text, 22, mask, validChars, invalidChars, 0, "", null, "");
    }

    /**
     * Constructs a new empty LTextButton with the specified
     * maximum length. The number of columns is 0.
     *
     * @param columns the maximum length of the text
     */
    public LTextButton(int columns) {
        this("Text Field", columns, "", "", "", 0, "", null, "");
    }

    /**
     * Constructs a new empty LTextButton with no maximum length.
     * The number of columns defaults to 22.
     */
    public LTextButton() {
        this("Text Field", 22, "", "", "", 0, "", null, "");
    }

    public LTextButton(CodingData codingdata) {
        codingData_F6 = codingdata;
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    private void initComponents() {//GEN-BEGIN:initComponents
        if (! mask.equals("")
            || ! validChars.equals("")
            || ! invalidChars.equals("")) {
            //Log.print("(LTextButton) textfield is formatted");
            textfield = new LFormattedTextField(columns, mask, validChars, invalidChars,projectId,fieldName, codingData, whichStatus,"","","",0,0,null);
        } else {
            //Log.print("(LTextButton) textfield is text");
            textfield = new LTextField(columns);
        }
        button = new javax.swing.JButton();

        setLayout(new java.awt.BorderLayout());

        textfield.setPreferredSize(null);

		textfield.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                textFieldKeyPressed(evt);
            }
        });

        add(textfield, java.awt.BorderLayout.CENTER);

        button.setText("...");
        button.setToolTipText("Click for Text Dialog");
        button.setPreferredSize(new java.awt.Dimension(20, 20));
        button.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonActionPerformed(evt);
            }
        });
        

        add(button, java.awt.BorderLayout.EAST);

    }//GEN-END:initComponents

    /**
     * Non-modal dialog to allow the user to navigate the image
     * in the viewer while keeping the text box open.
     */
    private void buttonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonActionPerformed
        if (select != null && select.isVisible()) {
            return;
        }
        textfield.requestFocus();
        select = new TextDialog(this, text, textfield.getText(), maximumColumns, textfield);
        select.setModal(false);
        select.setVisible(true);
    }//GEN-LAST:event_buttonActionPerformed

    public void setCheckBoxEnabled(boolean status) {
        if(getCheckBox() != null){
            getCheckBox().setEnabled(status);
            getCheckBox().setSelected(status);
            getComboBox().setEnabled(status);
        }
    }

    private void textFieldKeyPressed(java.awt.event.KeyEvent evt) {
        try {
            //enable the checkbox 
            if (getCheckBox() != null && button.isEnabled()) {
                getCheckBox().setEnabled(true);
                getCheckBox().setSelected(true);
                getComboBox().setEnabled(true);
            }
            switch (evt.getKeyCode()) {
                case KeyEvent.VK_F1:
                    dof1(evt);
                    break;
                case KeyEvent.VK_F6:
                    if ("CodingQC".equals(whichStatus) || "Admin".equals(whichStatus) || "Masking".equals(whichStatus)) {
                        doVerify(evt);
                        break;
                    }
            }
        } catch (Throwable th) {
            Log.quit(th);
        }
    }
    

    private int dof1(KeyEvent evt) {       
        
        final ClientTask task = new TaskSelectFieldDescription(fieldName, projectId);
        task.setCallback(new Runnable() {

            public void run() {
                try {
                    String description = (String) task.getResult();
                    String desc = "";
                    String fieldDescription = "";
                    StringTokenizer Tok = new StringTokenizer(description);
                    while (Tok.hasMoreTokens()) {
                        desc = desc + " " + Tok.nextToken();
                        if (desc.length() >= 45) {
                            fieldDescription = fieldDescription + "\n" + desc;
                            desc = "";
                        }
                    }
                    fieldDescription = fieldDescription + "\n" + desc;
                    String dialogm = "HELP TEXT FOR  " + fieldName;
                    Component parent = task.getParent();

                    JOptionPane.showMessageDialog(parent,
                            fieldDescription,
                            dialogm,
                            JOptionPane.INFORMATION_MESSAGE);
                } catch (Throwable th) {
                    Log.quit(th);
                }
            }
        });
        task.enqueue();

        return 0;
    }
    //For L1 verification dialog

    private int doVerify(KeyEvent evt) {
        ShowVerifyDialog verifyDialog = null;
        Object getComponent =  evt.getSource();
        LTextField field = (LTextField)getComponent;
        boolean checkIsEnabled = field.isEditable();
        if (codingData == null) {
            
                if(checkIsEnabled){
                verifyDialog = new ShowVerifyDialog(this, textfield.getText(), codingData_F6.valueMap, fieldName,
                      codingData_F6.childId, whichStatus, "LTextButton");
                verifyDialog.setLocationRelativeTo(this);
                verifyDialog.setModal(true);
                verifyDialog.show();
                }          
            
        } else {           
                if(checkIsEnabled){
                verifyDialog = new ShowVerifyDialog(this, textfield.getText(), codingData.valueMap, fieldName,
                    codingData.childId, whichStatus, "LTextButton");
                verifyDialog.setLocationRelativeTo(this);
                verifyDialog.setModal(true);
                verifyDialog.show();
                }           
        }
        
        return 0;
    }

    /**
     * Set all components on this panel to enabled(flag) and
     * set the coloring to match the default for <flag>.
     * @param flag true to enable, false to disable
     */
    public void setEnabled(boolean flag) {
        //Log.print("LTextButton.setEnabled: "+flag);
        textfield.setEditable(flag);
        button.setEnabled(flag);
        textfield.setForeground(Color.black);
        if (flag) {
            textfield.setBackground(Color.white);
        } else {
            textfield.setBackground(null);
        }
    }

    /**
     * Set the background color of the text field on this panel.
     * @param c the java.awt.Color to set the background
     */
    public void setBackground(Color c) {
        if (textfield != null) {
            textfield.setBackground(c);
        }
    }

    /**
     * Set the foreground (text) color of the text field on this panel.
     * @param c the java.awt.Color to set the foreground
     */
    public void setForeground(Color c) {
        if (textfield != null) {
            textfield.setForeground(c);
        }
    }

    /**
     * Gets the column width.
     * (Lexpar) set to be the width of the
     * character <em>n</em> for the font used.  Maybe this
     * isn't quite right, but it's a first approximation.
     *
     * @return the column width >= 1
     */
    protected int getColumnWidth() {
        if (lColumnWidth == 0) {
            FontMetrics metrics = getFontMetrics(getFont());
            lColumnWidth = metrics.charWidth('W');
        }
        return lColumnWidth;
    }

    /**
     * Returns the preferred size Dimensions needed for this 
     * TextField.  If a non-zero number of columns has been
     * set, the width is set to the columns multiplied by
     * the column width. (Lexpar) plus one -- seems to be
     * about right, at least for a first approximation.
     *
     * @return the dimensions
     */
    public Dimension getPreferredSize() {
        // Note.  super synchronizes on getTreeLock().  Shouldn't matter,
        // since we only mess with this on the event thread?
        Dimension size = textfield.getPreferredSize();
        int columns = (textfield.getColumns() > 22)
                ? 22 : textfield.getColumns();
        if (columns != 0) {
            size.width = 6 + (columns) * getColumnWidth();
        }
        return size;
    }

    public void clearField() {
        textfield.setText("");
    }

    public String getText() {
        return textfield.getText();
    }

    public Document getDocument() {
        //Log.print("(LTextButton.getDocument) " + textfield.getDocument());
        return textfield.getDocument();
    }

    public JTextField getTextField() {
        return textfield;
    }

    public void setColumns(int columns) {
        textfield.setColumns(columns);
    }

    public void setMaximumColumns(int columns) {
        maximumColumns = columns;
    }

    /**
     * Remove all leading spaces from <code>textField</code>.
     */
    public void stripLeadingSpace() {
        String text = getText();
        while (text.startsWith(" ")) {
            text = text.substring(1);
        }
        setText(text);
    }

    public void requestFocus() {
        textfield.requestFocus();
    }

    public void setText(String text) {
        //Log.print("(LTextButton.setText(" + text + ")");
        textfield.setText(text);
        if (text != null) {
            // if the text is longer than the receiving field,
            // set a tool tip to show all of it.
            if (text.length() > textfield.getColumns() && textfield.getColumns() > 0) {
                setToolTipText(text);
            }
        }
        if (textfield.hasFocus()) {
            textfield.selectAll();
        }
    }

    public void closeDialog() {
        if (select != null) {
            select.closeDialog(null);
            select = null;
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton button;
    private javax.swing.JTextField textfield;
    // End of variables declaration//GEN-END:variables

    // Delegate common LField calls to an LFieldImpl
    private LFieldImpl theImpl = new LFieldImpl(this);

    public void setChanged(boolean flag) {
        theImpl.setChanged(flag);
    }

    public boolean isChanged() {
        return theImpl.isChanged();
    }

    public void setCheckBox(JCheckBox checkBox) {
        theImpl.setCheckBox(checkBox);
    }

    public JCheckBox getCheckBox() {
        return theImpl.getCheckBox();
    }

    public void setTextField(JTextField textfield) {
        theImpl.setTextField(textfield);
    }

    public void setComboBox(LComboBox combo) {
        theImpl.setComboBox(combo);
    }

    public LComboBox getComboBox() {
        return theImpl.getComboBox();
    }
}
