# $Header: /home/common/cvsarea/ibase/dia/files/sql_text.txt,v 1.97.2.23 2006/02/07 18:18:07 nancy Exp $
# Content for sql_text table

$ AddEditTextFieldDialog.tablevalue
select tablevalue_id, value
 from tablevalue
 where tablespec_id = ?

$ assignment delete
delete from assignment where batch_id = ? and users_id = ?

$ batch comments select
select comments from batch_comments where batch_id = ?

$ batch comments update
replace into batch_comments set comments = ?, batch_id = [batch]

$ batch priority decrease
update batch set priority = priority-1 where batch_id = ?

$ batch priority increase
update batch set priority = priority+1 where batch_id = ?

$ batch status select
select status from batch where batch_id = ?

$ Batching.batches
select B.batch_id, B.status, B.batch_number, U.user_name
   , min(UQ.batch_id is null and TQ.batch_id is null), B.lft
   , S.batch_id is null, if(B.status = 'QAComplete',0,B.active_group)
from batch B
    left join assignment A using (batch_id)                          
    left join users U using (users_id)      
    left join usersqueue UQ on B.batch_id = UQ.batch_id
    left join teamsqueue TQ on B.batch_id = TQ.batch_id
    left join session S on S.batch_id = B.batch_id
where B.volume_id=?   
    and B.status <> "UBatched"    
group by batch_id

$ Batching.children
select C.child_id, P1. bates_number, P2.bates_number, P1.boundary_flag, C.lft
from child C
   inner join page P1 on P1.volume_id=C.volume_id and P1.seq=C.lft
   inner join page P2 on P2.volume_id=C.volume_id and P2.seq=C.rgt
where C.batch_id = ?

$ Batching.projects
select project_id, project_name, split_documents from project
where active

$ Batching.projectsTL
select P.project_id, project_name, split_documents
from project P
  inner join volume V using (project_id)
  inner join teamsvolume TV using (volume_id)
  inner join users U using (teams_id)
where U.users_id=[user]
group by P.project_id

$ Batching.teamsbatchqueue
select TQ.teamsqueue_id, P.project_name, B.batch_number
  , B.status, - B.priority, TQ.teams_id, TQ.batch_id, B.active_group
from teamsqueue TQ                                     
  inner join teams T using (teams_id)                  
  inner join batch B on TQ.batch_id=B.batch_id         
  inner join volume V on V.volume_id=B.volume_id       
  inner join project P on P.project_id = V.project_id  
where TQ.teams_id=?                                    

$ Batching.teamsqueue
select TQ.teamsqueue_id, T.team_name, B.status
from teamsqueue TQ
  inner join teams T using (teams_id)
  inner join batch B on TQ.batch_id=B.batch_id
where TQ.batch_id=?

$ Batching.teamsvolume
select TV.teamsvolume_id, T.team_name, T.teams_id
from teamsvolume TV
  inner join teams T using (teams_id) 
where TV.volume_id = ?

$ Batching.teamsvolumequeue
select TV.teamsvolume_id, V.volume_name, V.volume_id 
  from teamsvolume TV 
 inner join volume V using (volume_id) where TV.teams_id = ?

$ Batching.usersqueue
select UQ.usersqueue_id, user_name, B.status
from usersqueue UQ
  inner join users U using (users_id)
  inner join batch B on UQ.batch_id=B.batch_id
where UQ.batch_id=?

$ Batching.volumes
select volume_id, volume_name, sequence from volume
where project_id=? and volume.sequence > 0

$ check_unsaved_coding
select P.page_id
from batchuser BU
  inner join child C using (batch_id)
  inner join page P
     on P.volume_id = C.volume_id and P.seq = C.lft
  left join childcoded CC
     on CC.child_id = C.child_id and  CC.round = 0
where not BU.rework
   and BU.batch_id=[batch]
   and CC.child_id is null
order by C.lft
limit 1

$ check_unsaved_QA
select P.page_id
 from page P
   inner join child C on P.volume_id=C.volume_id and P.seq=C.lft
   inner join childcoded CC using (child_id)
 where C.volume_id = 5
   and CC.round = 0
   and CC.status='QA'
   and CC.users_id = 0
 order by C.lft
 limit 1

$ customerprice defaults
select unitize_page_price*.1, unitize_doc_price*.1
  , coding_page_price*.1, coding_doc_price*.1
from customerprice
where project_id = ? and volume_id = 0 and field_level = ?

$ customerprice level defaults
select unitize_page_price*.1, unitize_doc_price*.1
  , coding_page_price*.1, coding_doc_price*.1
from customerprice
where project_id = ? and volume_id = 0 and field_level = 0

$ CustomerPricePage.get levels
select distinct 0, TV.field_level
 from tablevalue TV
 inner join tablespec TS on (TS.tablespec_id = TV.tablespec_id)
 inner join projectfields PF on (PF.tablespec_id = TS.tablespec_id)
 inner join project P on (P.level_field_name = PF.field_name)
 where P.project_id = ?
 order by TV.field_level

$ CustomerPricePage.get volumes
select distinct volume_id, volume_name
 from volume
 where project_id = ? and sequence > 0
 order by sequence

$ CustomerPricePage.projectCombo
select distinct project_id, project_name
  from project
  where active

$ CustomerPricePage.customerpriceTable
select customerprice_id, coalesce(V.volume_name, "<Volume Default>"),
  CP.field_level,
  CP.unitize_page_price*.1, CP.unitize_doc_price*.1,
  CP.coding_page_price*.1, CP.coding_doc_price*.1,
  coalesce(V.volume_id, 0), coalesce(V.sequence, 0)
 from customerprice CP
 left join volume V on (V.volume_id = CP.volume_id)
 where CP.project_id = ?

$ DiaClient.get users_id
select users_id from users where users_id = [user];

$ ExportPage.get all volumes
select distinct V.volume_id, V.volume_name, max(B.status -0)
  from volume V, batch B
  where V.project_id = ?
    AND V.sequence > 0
    AND V.volume_id = B.volume_id
  group by V.volume_id
  order by V.volume_name

$ ExportPage.get qced volumes
select distinct V.volume_id, V.volume_name, max(B.status -0)
  from volume V, batch B
  where V.project_id = ?
    AND V.sequence > 0
    AND V.volume_id = B.volume_id
    and B.status - 0 >= 7
  group by V.volume_id
  order by V.volume_name

$ ExportPage.get all batches
select distinct B.batch_id, B.batch_number, max(B.status -0)
  from volume V, batch B
  where V.volume_id = ?
    AND V.volume_id = B.volume_id
    and B.status - 0 >= 5
  group by B.batch_number
  order by B.batch_number

$ ExportPage.get export data
select export_name from export
  order by export_name

$ ExportPage.get qced batches
select distinct B.batch_id, B.batch_number, max(B.status -0)
  from volume V, batch B
  where V.volume_id = ?
    AND V.volume_id = B.volume_id
    and B.status - 0 >= 7
  group by B.batch_number
  order by B.batch_number

$ ExportPage.get export delimiters
select force_export, uppercase, uppercase_names,
  field_delimiter, text_qualifier, value_separator,
  date_format, missing_date, missing_year, missing_month,
  missing_day, missing_date_character, name_mask1, name_mask2, name_mask3, name_mask4, brs_format
  from export
  where export_name = ?

$ ExportPage.projectCombo
select distinct P.project_id, P.project_name, IF(max(B.status -0) > 5, 1, 0)
  from project P, batch B
  inner join volume V on (V.project_id = P.project_id)
  where V.volume_id = B.volume_id
  group by P.project_id

$ ExportPage.readOffset
select page_id
from page
where volume_id = ?
    and offset > 0
limit 1;

$ ExportPage.readPages
select P.seq, P.bates_number, P.path, P.filename, P.boundary_flag, P.offset, P.rotate,
  C.lft, C.rgt, P.file_type, V.volume_name, B.status - 0, R.lft, R.rgt,
  PI.sequence, PI.issue_name, B.status, B.batch_number,
  beginP.bates_number, endP.bates_number, P.group_one_path, P.group_one_filename,
  P.document_number, V.original_volume_name 
from page P
  inner join child C using (child_id)
  inner join range R on (C.range_id = R.range_id)
  inner join batch B on (C.batch_id = B.batch_id)
  inner join volume V using (volume_id)
  inner join page beginP on (beginP.seq = R.lft and beginP.volume_id = V.volume_id)
  inner join page endP on (endP.seq = R.rgt and endP.volume_id = V.volume_id)
  left join pageissue PI on (P.page_id = PI.page_id)
where  B.volume_id = ?
    and B.batch_number between ? and ?
    and B.status - 0 >= ?
ORDER by seq , PI.sequence

$ ExportPage.readProjectfields
select projectfields_id, P.project_id, sequence,
  field_name, field_type, field_size, repeated,
  required, default_value, min_value, max_value,
  tablespec_id, table_mandatory, mask, valid_chars, invalid_chars, charset,
  type_field, type_value, unitize, spell_check, field_level, minimum_size, tag_name
  from projectfields
  inner join project P using (project_id)
  where P.project_id = ?
  order by sequence
  
$ ExportPage.readValues
(select PF.field_name, C.lft, PF.sequence, LV.sequence AS sequ, LV.value, B.status - 0
  from child C, project P, batch B, volume V
  join longvalue LV ON (C.child_id = LV.child_id AND LV.field_name = PF.field_name)
  inner join projectfields PF on (P.project_id = PF.project_id
   AND PF.field_level in (0, TV.field_level))
        left join value DLVA ON (C.child_id = DLVA.child_id
          AND DLVA.field_name = P.level_field_name)
        
        left join projectfields DLPF on (P.project_id = DLPF.project_id
                    and P.level_field_name = DLPF.field_name)
        left join tablevalue TV on (TV.tablespec_id = DLPF.tablespec_id
                   and TV.value = DLVA.value)
where P.project_id = ?
    and V.volume_id = ?
    and V.project_id = P.project_id
    and B.volume_id = V.volume_id
    and B.batch_number >= ?
    and B.batch_number <= ?
    and B.status - 0 >= ?
    and C.volume_id = V.volume_id
    and C.batch_id = B.batch_id
  GROUP by C.lft, PF.sequence, sequ)
UNION
(select PF.field_name, C.lft, PF.sequence, VA.sequence AS sequ, VA.value, B.status - 0
  from child C, project P, batch B, volume V
  join value VA ON (C.child_id = VA.child_id AND VA.field_name = PF.field_name)
  inner join projectfields PF on (P.project_id = PF.project_id
   AND PF.field_level in (0, TV.field_level))
        left join value DLVA ON (C.child_id = DLVA.child_id
          AND DLVA.field_name = P.level_field_name)
        
        left join projectfields DLPF on (P.project_id = DLPF.project_id
                    and P.level_field_name = DLPF.field_name)
        left join tablevalue TV on (TV.tablespec_id = DLPF.tablespec_id
                   and TV.value = DLVA.value)
  where P.project_id = ?
    and V.volume_id = ?
    and V.project_id = P.project_id
    and B.volume_id = V.volume_id
    and B.batch_number >= ?
    and B.batch_number <= ?
    and B.status - 0 >= ?
    and C.volume_id = V.volume_id
    and C.batch_id = B.batch_id
  GROUP by C.lft, PF.sequence, sequ)
UNION
(select PF.field_name, C.lft, PF.sequence, NV.sequence AS sequ,
  if(last_name='','',concat(last_name,
               if(first_name='','',concat(', ',first_name,' ',middle_name)),
               if(organization='','',concat(' / ',organization)))), B.status - 0
  from child C, project P, batch B, volume V
  join namevalue NV ON (C.child_id = NV.child_id AND NV.field_name = PF.field_name)
  inner join projectfields PF on (P.project_id = PF.project_id
   AND PF.field_level in (0, TV.field_level))
        left join value DLVA ON (C.child_id = DLVA.child_id
          AND DLVA.field_name = P.level_field_name)
        
        left join projectfields DLPF on (P.project_id = DLPF.project_id
                    and P.level_field_name = DLPF.field_name)
        left join tablevalue TV on (TV.tablespec_id = DLPF.tablespec_id
                   and TV.value = DLVA.value)
  where P.project_id = ?
    and V.volume_id = ?
    and V.project_id = P.project_id
    and B.volume_id = V.volume_id
    and B.batch_number >= ?
    and B.batch_number <= ?
    and B.status - 0 >= ?
    and C.volume_id = V.volume_id
    and C.batch_id = B.batch_id
  GROUP by C.lft, PF.sequence, sequ)
  ORDER by 2, 3, 4

$ get assigned batch
select A.batch_id, B.batch_number, P.project_name
 from assignment A
   inner join batch B using (batch_id)
   inner join volume V on (B.volume_id = V.volume_id)
   inner join project P on (V.project_id = P.project_id)
 where users_id = [user]
   and status=?

$ get project names
select project_id, project_name from project
where active
order by project_name

$ get tablespec names
select tablespec_id, table_name, table_type from tablespec
 where (project_id = ? or project_id = 0) and table_type = ? order by table_name

$ get teams names
select T.teams_id, T.team_name, U.user_name
from teams T left join users U on (T.users_id = U.users_id)
order by T.team_name

$ get unassigned users names
select U.users_id, U.user_name
from users U
where U.teams_id = 0 and U.active
order by U.user_name

$ get users names by team
select U.users_id, U.user_name
from users U left join teams T on (U.teams_id = T.teams_id)
where (T.teams_id = ? or U.teams_id = 0)
  and U.active
order by U.user_name

$ Import Export.get all volumes
select distinct V.volume_id, V.volume_name, max(B.status -0)
  from volume V, batch B
  where V.project_id = ?
    AND V.sequence > 0
    AND V.volume_id = B.volume_id
    AND B.lft >= V.lft and B.rgt <= V.rgt
  group by V.volume_id
  order by V.volume_name

$ MailPanel.mailreceivedTable
select MR.mailreceived_id, MR.status, U.user_name, MS.subject, (-MS.time_sent)
 from mailreceived MR
    left join mailsent MS on (MR.mailsent_id = MS.mailsent_id)
    left join users U on (U.users_id = MS.sender_users_id)
 where [user] = ? and MR.recipient_users_id = [user] and MR.status <> 'Deleted'

$ MailPanel.mailsentTable
select MS.mailsent_id, MS.recipient_list, MS.subject, (-MS.time_sent)
 from mailsent MS
 where [user] = ? and MS.sender_users_id = [user] and MS.status <> 'Deleted'

$ open binder check
select P.project_name, V.volume_id, B.batch_id
 from volume V0
   inner join project P using(project_id)
   inner join volume V using(project_id)
   inner join batch B using (volume_id)
 where V0.volume_id=[volume]
   and V.sequence=-1

$ pageissue select
select issue_name, sequence from pageissue where page_id = ? order by sequence

$ pageissue select one
select issue_name from pageissue where page_id = ? and sequence = ?

$ PricePage.get levels
select distinct 0, TV.field_level
 from tablevalue TV
 inner join tablespec TS on (TS.tablespec_id = TV.tablespec_id)
 inner join projectfields PF on (PF.tablespec_id = TS.tablespec_id)
 inner join project P on (P.level_field_name = PF.field_name)
 where P.project_id = ?
 order by TV.field_level

$ PricePage.get volumes
select distinct volume_id, volume_name
 from volume
 where project_id = ? and sequence > 0
 order by sequence

$ PricePage.projectCombo
select distinct project_id, project_name
  from project
  where active

$ PricePage.unitpriceTable
select unitprice_id, coalesce(V.volume_name, "<Volume Default>"),
  UP.field_level,
  UP.unitize_page_price*.1, UP.unitize_doc_price*.1, UP.uqc_page_price*.1, UP.uqc_doc_price*.1,
  UP.coding_page_price*.1, UP.coding_doc_price*.1, UP.codingqc_page_price*.1, UP.codingqc_doc_price*.1,
  coalesce(V.volume_id, 0), coalesce(V.sequence, 0)
 from unitprice UP
 left join volume V on (V.volume_id = UP.volume_id)
 where UP.project_id = ?

$ ProjectAdminPage.delete_field
delete projectfields.*
from projectfields inner join project using (project_id)
where projectfields_id = ?
  and (level_field_name is null or level_field_name <> field_name);

$ ProjectAdminPage.get_split_documents
select split_documents from project
where project_id = ?;

$ ProjectAdminPage.split_documents
update project
set split_documents = ?
where project_id = ?;

$ ProjectAdminPage.projectfieldsTable
select projectfields_id, field_name, field_type, field_size, minimum_size, required
     , repeated, spell_check, unitize, TS.table_name, table_mandatory
     , if(PF.field_name = P.level_field_name, "*", PF.field_level), field_group
     , default_value, min_value, max_value
     , if(mask <> '' or valid_chars <> '' or invalid_chars <> '', 'Yes', '')
     , charset, type_field, type_value, PF.project_id, sequence
from projectfields PF left join project P on (PF.project_id = P.project_id)
        left join tablespec TS on (TS.tablespec_id = PF.tablespec_id)
where PF.project_id = ?

$ projectfields by id select
select PF.project_id, sequence, field_name, field_type, field_size, repeated
     , required, default_value, min_value, max_value, TS.table_name, table_mandatory
     , mask, valid_chars, invalid_chars, charset, type_field, type_value, unitize, spell_check
     , if(field_name = P.level_field_name, "*", field_level), minimum_size, tag_name, field_group
from projectfields PF
inner join project P using (project_id)
        left join tablespec TS on (TS.tablespec_id = PF.tablespec_id)
where projectfields_id = ?

$ qa_report_error
select coalesce(team_name,'') as '@Team'
  , coalesce(user_name,'') as 'Coder'
  , sum(field_count) as "+Nbr Fields"
  , sum(change_count) as "%Pct Changed"
  , sum(error_count) as "%Pct Errors"
from childerror E
  inner join child C using (child_id)
  inner join childcoded CC0 using (child_id)
  inner join childcoded CC using (child_id)
  left join users U using (users_id)
  left join teams T using (teams_id)
where CC0.round=0
  and CC.round=1
  and CC0.status='QA'
  and C.volume_id=[volume]
group by team_name, user_name, CC.users_id
order by team_name, user_name, CC.users_id

$ qaClose.first_remaining_page
select P.page_id
from page P
   inner join child C using (child_id)
   inner join childcoded CC using (child_id)
where C.volume_id=[volume]
  and CC.round = 0
  and CC.status='QA'
order by C.lft
limit 1

$ QACloseDialog.team
select distinct T.team_name, T.teams_id
from teams T
   inner join users U using (teams_id)
   inner join batchuser BU on BU.coder_id = U.users_id
   inner join batch B using (batch_id)
where B.volume_id=[volume]
   and B.status = 'QA'
order by T.team_name

$ QACloseDialog.coder
select U.user_name, U.users_id
     , max(B.status = 'QCComplete'), max(B.status = 'QA') 
from users U
   inner join batchuser BU on BU.coder_id = U.users_id
   inner join batch B using (batch_id)
where B.volume_id=[volume]
   and B.status = 'QA'
group by U.user_name, U.users_id
order by U.user_name

$ QASampleDialog.team
select distinct T.team_name, T.teams_id
from teams T
   inner join users U using (teams_id)
   inner join batchuser BU on BU.coder_id = U.users_id
   inner join batch B using (batch_id)
where B.volume_id=[volume]
   and B.status in ('QCComplete', 'QA')
order by T.team_name

$ QASampleDialog.coder
select U.user_name, U.users_id
     , max(B.status = 'QCComplete'), max(B.status = 'QA') 
from users U
   inner join batchuser BU on BU.coder_id = U.users_id
   inner join batch B using (batch_id)
where B.volume_id=[volume]
   and B.status in ('QCComplete', 'QA')
group by U.user_name, U.users_id
order by U.user_name

$ QAVolumeSelectionDialog.volumes
select project_name, volume_name
          , sum(status in ('Coding', 'CodingQC'))
          , sum(status='QCComplete') as qc_count
          , sum(status='QA') as qa_count
          , sum(status='QAComplete') 
          , V.volume_id, P.project_id
 from batch B
   inner join volume V using(volume_id)
   inner join project P using(project_id)
   left join session S on (S.volume_id = V.volume_id and S.batch_id = 0)
 where S.volume_id is null
   and V.sequence > 0
 group by volume_id
 having qc_count > 0 or qa_count > 0
 order by project_name, volume_name

$ qc_report_batch_project
select if(B.status like 'U%', concat('U-',B.batch_number), B.batch_number)
        as `Batch`   
    , V.volume_name as Volume    
    , B.status as `Status` 
    , case 
        when S.batch_id is not null then 'In Use' 
        when A.batch_id is not null then 'Assigned' 
        else '' end as `Asg/Use`
    , if(X.rework,'YES','') as Rework
    , count(distinct C.child_id) as `+Docs`
    , count(*) as `+Pages`
    , coalesce(U.user_name,'')  as `Coder Id`  
    , coalesce(Q.user_name,'')  as `QCer Id`  
    , coalesce(date_format(from_unixtime(mod_time/1000),'%Y-%m-%d %H:%i'),'') as `Mod Time` 
from volume V0
   inner join volume V using (project_id)           
   inner join batch B using (volume_id)
   inner join child C using (batch_id)
   inner join page P using (child_id)        
   left join session S on S.volume_id=B.volume_id and S.batch_id=B.batch_id
   left join assignment A on A.batch_id=B.batch_id
   left join batchuser X on X.batch_id=B.batch_id
   left join users U on X.coder_id=U.users_id
   left join users Q on X.qc_id=Q.users_id
where V0.volume_id = [volume]
   and V.sequence > 0
   and B.status<>'UBatched'
group by B.batch_id
order by B.status not like 'U%', B.batch_number

$ qc_report_batch_project_by_volume
select V.volume_name as `@Volume`
    , if(B.status like 'U%', concat('U-',B.batch_number), B.batch_number)
        as `Batch`   
    , B.status as `Status` 
    , case 
        when S.batch_id is not null then 'In Use' 
        when A.batch_id is not null then 'Assigned' 
        else '' end as `Asg/Use`
    , if(X.rework,'YES','') as Rework
    , count(distinct C.child_id) as `+Docs`
    , count(*) as `+Pages`
    , coalesce(U.user_name,'')  as `Coder Id`  
    , coalesce(Q.user_name,'')  as `QCer Id`  
    , coalesce(date_format(from_unixtime(mod_time/1000),'%Y-%m-%d %H:%i'),'') as `Mod Time` 
from volume V0
   inner join volume V using (project_id)           
   inner join batch B using (volume_id)
   inner join child C using (batch_id)
   inner join page P using (child_id)        
   left join session S on S.volume_id=B.volume_id and S.batch_id=B.batch_id
   left join assignment A on A.batch_id=B.batch_id
   left join batchuser X on X.batch_id=B.batch_id
   left join users U on X.coder_id=U.users_id
   left join users Q on X.qc_id=Q.users_id
where V0.volume_id = [volume]
   and V.sequence > 0
   and B.status<>'UBatched'
group by B.batch_id
order by V.volume_name, B.status not like 'U%', B.batch_number

$ qc_report_batch_project_by_status
select B.status as `@Status` 
    , V.volume_name as `Volume`
    , if(B.status like 'U%', concat('U-',B.batch_number), B.batch_number)
        as `Batch`   
    , case 
        when S.batch_id is not null then 'In Use' 
        when A.batch_id is not null then 'Assigned' 
        else '' end as `Asg/Use`
    , if(X.rework,'YES','') as Rework
    , count(distinct C.child_id) as `+Docs`
    , count(*) as `+Pages`
    , coalesce(U.user_name,'')  as `Coder Id`  
    , coalesce(Q.user_name,'')  as `QCer Id`  
    , coalesce(date_format(from_unixtime(mod_time/1000),'%Y-%m-%d %H:%i'),'') as `Mod Time` 
from volume V0
   inner join volume V using (project_id)           
   inner join batch B using (volume_id)
   inner join child C using (batch_id)
   inner join page P using (child_id)        
   left join session S on S.volume_id=B.volume_id and S.batch_id=B.batch_id
   left join assignment A on A.batch_id=B.batch_id
   left join batchuser X on X.batch_id=B.batch_id
   left join users U on X.coder_id=U.users_id
   left join users Q on X.qc_id=Q.users_id
where V0.volume_id = [volume]
   and V.sequence > 0
   and B.status<>'UBatched'
group by B.batch_id
order by B.status not like 'U%', B.status, B.batch_number

$ qc_report_batch_project_by_volume_status
select V.volume_name as `@Volume`
    , B.status as `@Status` 
    , if(B.status like 'U%', concat('U-',B.batch_number), B.batch_number)
        as `Batch`   
    , case 
        when S.batch_id is not null then 'In Use' 
        when A.batch_id is not null then 'Assigned' 
        else '' end as `Asg/Use`
    , if(X.rework,'YES','') as Rework
    , count(distinct C.child_id) as `+Docs`
    , count(*) as `+Pages`
    , coalesce(U.user_name,'')  as `Coder Id`  
    , coalesce(Q.user_name,'')  as `QCer Id`  
    , coalesce(date_format(from_unixtime(mod_time/1000),'%Y-%m-%d %H:%i'),'') as `Mod Time` 
from volume V0
   inner join volume V using (project_id)           
   inner join batch B using (volume_id)
   inner join child C using (batch_id)
   inner join page P using (child_id)        
   left join session S on S.volume_id=B.volume_id and S.batch_id=B.batch_id
   left join assignment A on A.batch_id=B.batch_id
   left join batchuser X on X.batch_id=B.batch_id
   left join users U on X.coder_id=U.users_id
   left join users Q on X.qc_id=Q.users_id
where V0.volume_id = [volume]
   and V.sequence > 0
   and B.status<>'UBatched'
group by B.batch_id
order by V.volume_name, B.status not like 'U%', B.status, B.batch_number

$ qc_report_error
select coalesce(team_name,'') as '@Team'
  , coalesce(user_name,'') as 'Coder'
  , sum(field_count) as "+Nbr Fields"
  , sum(change_count) as "%Pct Changed"
  , sum(error_count) as "%Pct Errors"
from childerror E
  inner join child C using (child_id)
  inner join childcoded CC using (child_id)
  left join users U using (users_id)
  left join teams T using (teams_id)
where CC.round=1
  and C.batch_id=[batch]
group by team_name, user_name, CC.users_id
order by team_name, user_name, CC.users_id

$ qc_report_open_batch_team
select PR.project_name as `@Project`
    , if(substring(B.status,1,1)='U', concat('U-',B.batch_number), B.batch_number)
        as `Batch`       
    , B.status as `Status` 
    , case 
        when S.batch_id is not null then 'In Use' 
        when A.batch_id is not null then 'Assigned' 
        else '' end as `Asg/Use`
    , if(X.rework,'YES','') as Rework
    , count(distinct C.child_id) as `+Docs`
    , count(*) as `+Pages`
    , U.user_name as `Coder Id`  
    , coalesce(date_format(from_unixtime(mod_time/1000),'%Y-%m-%d %H:%i'),'')
        as `Mod Time` 
from batch B           
   inner join child C using (batch_id)
   inner join page P using (child_id)        
   inner join volume V using(volume_id)
   inner join project PR using (project_id)
   inner join batchuser X on X.batch_id=B.batch_id
   inner join users U on X.coder_id=U.users_id
   inner join users U0 using (teams_id)
   left join session S on S.batch_id=B.batch_id
   left join assignment A on A.batch_id=B.batch_id
where U0.users_id=[user]
  and B.status in ('Unitize', 'UQC', 'Coding', 'CodingQC')
group by B.batch_id
order by project_name, substring(B.status,1,1)<>'U', B.batch_number

$ qc_report_open_batch_team_by_coder
select coalesce(U.user_name,'')  as `@Coder Id`  
    , PR.project_name as `Project`
    , if(substring(B.status,1,1)='U', concat('U-',B.batch_number), B.batch_number)
        as `Batch`       
    , B.status as `Status` 
    , case 
        when S.batch_id is not null then 'In Use' 
        when A.batch_id is not null then 'Assigned' 
        else '' end as `Asg/Use`
    , if(X.rework,'YES','') as Rework
    , count(distinct C.child_id) as `+Docs`
    , count(*) as `+Pages`
    , coalesce(date_format(from_unixtime(mod_time/1000),'%Y-%m-%d %H:%i'),'') as
        `Mod Time` 
from batch B           
   inner join child C using (batch_id)
   inner join page P using (child_id)        
   inner join volume V using(volume_id)
   inner join project PR using (project_id)
   inner join batchuser X on X.batch_id=B.batch_id
   inner join users U on X.coder_id=U.users_id
   inner join users U0 using (teams_id)
   left join session S on S.batch_id=B.batch_id
   left join assignment A on A.batch_id=B.batch_id
where U0.users_id=[user]
  and B.status in ('Unitize', 'UQC', 'Coding', 'CodingQC')
group by B.batch_id
order by U.user_name
   , project_name
   , substring(B.status,1,1)<>'U', B.batch_number

$ qc_report_qc_batch_team
select PR.project_name as `@Project`
    , if(substring(B.status,1,1)='U', concat('U-',B.batch_number), B.batch_number)
        as `Batch`       
    , B.status as `Status` 
    , case 
        when S.batch_id is not null then 'In Use' 
        when A.batch_id is not null then 'Assigned' 
        else '' end as `Asg/Use`
    , if(X.rework,'YES','') as Rework
    , count(distinct C.child_id) as `+Docs`
    , count(*) as `+Pages`
    , U.user_name as `Coder Id`  
    , coalesce(date_format(from_unixtime(mod_time/1000),'%Y-%m-%d %H:%i'),'')
        as `Mod Time` 
from batch B           
   inner join child C using (batch_id)
   inner join page P using (child_id)        
   inner join volume V using(volume_id)
   inner join project PR using (project_id)
   inner join batchuser X on X.batch_id=B.batch_id
   inner join users U on X.coder_id=U.users_id
   inner join users U0 using (teams_id)
   left join session S on S.batch_id=B.batch_id
   left join assignment A on A.batch_id=B.batch_id
where U0.users_id=[user]
   and B.status = 'CodingQC'
group by B.batch_id
order by project_name, substring(B.status,1,1)<>'U', B.batch_number

$ qc_report_qc_batch_team_by_coder
select coalesce(U.user_name,'')  as `@Coder Id`  
    , PR.project_name as `Project`
    , if(substring(B.status,1,1)='U', concat('U-',B.batch_number), B.batch_number)
        as `Batch`       
    , B.status as `Status` 
    , case 
        when S.batch_id is not null then 'In Use' 
        when A.batch_id is not null then 'Assigned' 
        else '' end as `Asg/Use`
    , if(X.rework,'YES','') as Rework
    , count(distinct C.child_id) as `+Docs`
    , count(*) as `+Pages`
    , coalesce(date_format(from_unixtime(mod_time/1000),'%Y-%m-%d %H:%i'),'')
        as `Mod Time` 
from batch B           
   inner join child C using (batch_id)
   inner join page P using (child_id)        
   inner join volume V using(volume_id)
   inner join project PR using (project_id)
   inner join batchuser X on X.batch_id=B.batch_id
   inner join users U on X.coder_id=U.users_id
   inner join users U0 using (teams_id)
   left join session S on S.batch_id=B.batch_id
   left join assignment A on A.batch_id=B.batch_id
where U0.users_id=[user]
   and B.status = 'CodingQC'
group by B.batch_id
order by U.user_name
   , project_name
   , substring(B.status,1,1)<>'U', B.batch_number

$ qc_report_summary_project
select V.volume_name as `@Volume`
    , if(B.status='QCComplete', 'QA', B.status) as Status
    , count(distinct C.child_id) as `+Documents`
    , count(*) as `+Pages`
    , V.image_path as `Image Path`
from volume V0
    inner join volume V using (project_id)
    inner join batch B using (volume_id)
    inner join child C using (batch_id)
    inner join page P using (child_id)
where V0.volume_id = [volume]
    and V.sequence > 0
    and B.status <> 'UBatched'
group by V.volume_name, B.Status
order by V.volume_name, B.status

$ ReportPage.projectCombo
select project_id, project_name from project
where active

$ ReportPage.projectComboTL
select P.project_id, project_name
from project P
  inner join volume V using (project_id)
  inner join teamsvolume TV using (volume_id)
  inner join users U using (teams_id)
where U.users_id=[user]
group by P.project_id

$ ReportPage.teamCombo
select T.teams_id, team_name
from teams T

$ ReportPage.teamComboTL
select T.teams_id, team_name
from teams T
  inner join users U0 using (teams_id)
where U0.users_id=[user]
group by T.teams_id

$ report_batch_credit
select P.project_name as `@Project`
  , coalesce(V.volume_name, '') as `@Volume`
  , if (BC.status like 'U%', concat('U-',BC.batch_number), BC.batch_number)
      as `Batch`
  , BC.status as Status
  , BC.field_level as Level
  , BC.active_group as 'Group'
  , if(BC.rework, 'YES', '') as Rework
  , coalesce(U.user_name, '?') as `User ID`
  , BC.child_count as `+Documents`
  , BC.page_count as `+Pages`
from batchcredit BC
   inner join project P on P.project_id=BC.project_id
   left join volume V on V.volume_id = BC.volume_id
   left join users U on U.users_id = BC.users_id
where BC.credit_time between ? and ?
order by P.project_name, V.volume_name, BC.status like 'U%', BC.batch_number
  , BC.status, BC.active_group, BC.credit_time

$ report_batch_project
select if(B.status like 'U%', concat('U-',B.batch_number), B.batch_number)
        as `Batch`   
    , volume_name as Volume    
    , B.status as `Status` 
    , case 
        when S.batch_id is not null then 'In Use' 
        when A.batch_id is not null then 'Assigned' 
        else '' end as `Asg/Use`
    , if(X.rework,'YES','') as Rework
    , count(distinct C.child_id) as `+Docs`
    , count(*) as `+Pages`
    , coalesce(U.user_name,'')  as `Coder Id`  
    , coalesce(Q.user_name,'')  as `QCer Id`  
    , coalesce(date_format(from_unixtime(mod_time/1000),'%Y-%m-%d %H:%i'),'') as `Mod Time` 
from volume V           
   inner join batch B using (volume_id)
   inner join child C using (batch_id)
   inner join page P using (child_id)        
   left join session S on S.volume_id=B.volume_id and S.batch_id=B.batch_id
   left join assignment A on A.batch_id=B.batch_id
   left join batchuser X on X.batch_id=B.batch_id
   left join users U on X.coder_id=U.users_id
   left join users Q on X.qc_id=Q.users_id
where V.project_id=?
   and V.sequence > 0
   and B.status<>'UBatched'
group by B.batch_id
order by B.status not like 'U%', B.batch_number

$ report_batch_project_by_volume
select volume_name as `@Volume`
    , if(B.status like 'U%', concat('U-',B.batch_number), B.batch_number)
        as `Batch`   
    , B.status as `Status` 
    , case 
        when S.batch_id is not null then 'In Use' 
        when A.batch_id is not null then 'Assigned' 
        else '' end as `Asg/Use`
    , if(X.rework,'YES','') as Rework
    , count(distinct C.child_id) as `+Docs`
    , count(*) as `+Pages`
    , coalesce(U.user_name,'')  as `Coder Id`  
    , coalesce(Q.user_name,'')  as `QCer Id`  
    , coalesce(date_format(from_unixtime(mod_time/1000),'%Y-%m-%d %H:%i'),'') as `Mod Time` 
from volume V           
   inner join batch B using (volume_id)
   inner join child C using (batch_id)
   inner join page P using (child_id)        
   left join session S on S.volume_id=B.volume_id and S.batch_id=B.batch_id
   left join assignment A on A.batch_id=B.batch_id
   left join batchuser X on X.batch_id=B.batch_id
   left join users U on X.coder_id=U.users_id
   left join users Q on X.qc_id=Q.users_id
where V.project_id=?
   and V.sequence > 0
   and B.status<>'UBatched'
group by B.batch_id
order by V.volume_name, B.status not like 'U%', B.batch_number

$ report_batch_project_by_status
select B.status as `@Status` 
    , volume_name as `Volume`
    , if(B.status like 'U%', concat('U-',B.batch_number), B.batch_number)
        as `Batch`   
    , case 
        when S.batch_id is not null then 'In Use' 
        when A.batch_id is not null then 'Assigned' 
        else '' end as `Asg/Use`
    , if(X.rework,'YES','') as Rework
    , count(distinct C.child_id) as `+Docs`
    , count(*) as `+Pages`
    , coalesce(U.user_name,'')  as `Coder Id`  
    , coalesce(Q.user_name,'')  as `QCer Id`  
    , coalesce(date_format(from_unixtime(mod_time/1000),'%Y-%m-%d %H:%i'),'') as `Mod Time` 
from volume V           
   inner join batch B using (volume_id)
   inner join child C using (batch_id)
   inner join page P using (child_id)        
   left join session S on S.volume_id=B.volume_id and S.batch_id=B.batch_id
   left join assignment A on A.batch_id=B.batch_id
   left join batchuser X on X.batch_id=B.batch_id
   left join users U on X.coder_id=U.users_id
   left join users Q on X.qc_id=Q.users_id
where V.project_id=?
   and V.sequence > 0
   and B.status<>'UBatched'
group by B.batch_id
order by B.status not like 'U%', B.status, B.batch_number

$ report_batch_project_by_volume_status
select volume_name as `@Volume`
    , B.status as `@Status` 
    , if(B.status like 'U%', concat('U-',B.batch_number), B.batch_number)
        as `Batch`   
    , case 
        when S.batch_id is not null then 'In Use' 
        when A.batch_id is not null then 'Assigned' 
        else '' end as `Asg/Use`
    , if(X.rework,'YES','') as Rework
    , count(distinct C.child_id) as `+Docs`
    , count(*) as `+Pages`
    , coalesce(U.user_name,'')  as `Coder Id`  
    , coalesce(Q.user_name,'')  as `QCer Id`  
    , coalesce(date_format(from_unixtime(mod_time/1000),'%Y-%m-%d %H:%i'),'') as `Mod Time` 
from volume V           
   inner join batch B using (volume_id)
   inner join child C using (batch_id)
   inner join page P using (child_id)        
   left join session S on S.volume_id=B.volume_id and S.batch_id=B.batch_id
   left join assignment A on A.batch_id=B.batch_id
   left join batchuser X on X.batch_id=B.batch_id
   left join users U on X.coder_id=U.users_id
   left join users Q on X.qc_id=Q.users_id
where V.project_id=?
   and V.sequence > 0
   and B.status<>'UBatched'
group by B.batch_id
order by V.volume_name, B.status not like 'U%', B.status, B.batch_number

$ report_open_batch
select PR.project_name as `@Project`
    , if(substring(B.status,1,1)='U', concat('U-',B.batch_number), B.batch_number)
        as `Batch`       
    , B.status as `Status` 
    , case 
        when S.batch_id is not null then 'In Use' 
        when A.batch_id is not null then 'Assigned' 
        else '' end as `Asg/Use`
    , if(X.rework,'YES','') as Rework
    , count(distinct C.child_id) as `+Docs`
    , count(*) as `+Pages`
    , coalesce(U.user_name,'')  as `Coder Id`  
    , coalesce(T.team_name,'')  as `Team`  
    , coalesce(date_format(from_unixtime(mod_time/1000),'%Y-%m-%d %H:%i'),'')
        as `Mod Time` 
from batch B           
   inner join child C using (batch_id)
   inner join page P using (child_id)        
   inner join volume V using(volume_id)
   inner join project PR using (project_id)
   inner join batchuser X on X.batch_id=B.batch_id
   inner join users U on X.coder_id=U.users_id
   inner join teams T using (teams_id)
   left join session S on S.batch_id=B.batch_id
   left join assignment A on A.batch_id=B.batch_id
where B.status in ('Unitize', 'UQC', 'Coding', 'CodingQC')
group by B.batch_id
order by project_name, substring(B.status,1,1)<>'U', B.batch_number

$ report_open_batch_team
select PR.project_name as `@Project`
    , if(substring(B.status,1,1)='U', concat('U-',B.batch_number), B.batch_number)
        as `Batch`       
    , B.status as `Status` 
    , case 
        when S.batch_id is not null then 'In Use' 
        when A.batch_id is not null then 'Assigned' 
        else '' end as `Asg/Use`
    , if(X.rework,'YES','') as Rework
    , count(distinct C.child_id) as `+Docs`
    , count(*) as `+Pages`
    , U.user_name as `Coder Id`  
    , coalesce(date_format(from_unixtime(mod_time/1000),'%Y-%m-%d %H:%i'),'')
        as `Mod Time` 
from batch B           
   inner join child C using (batch_id)
   inner join page P using (child_id)        
   inner join volume V using(volume_id)
   inner join project PR using (project_id)
   inner join batchuser X on X.batch_id=B.batch_id
   inner join users U on X.coder_id=U.users_id
   left join session S on S.batch_id=B.batch_id
   left join assignment A on A.batch_id=B.batch_id
where U.teams_id=?
  and B.status in ('Unitize', 'UQC', 'Coding', 'CodingQC')
group by B.batch_id
order by project_name, substring(B.status,1,1)<>'U', B.batch_number

$ report_open_batch_team_by_coder
select coalesce(U.user_name,'')  as `@Coder Id`  
    , PR.project_name as `Project`
    , if(substring(B.status,1,1)='U', concat('U-',B.batch_number), B.batch_number)
        as `Batch`       
    , B.status as `Status` 
    , case 
        when S.batch_id is not null then 'In Use' 
        when A.batch_id is not null then 'Assigned' 
        else '' end as `Asg/Use`
    , if(X.rework,'YES','') as Rework
    , count(distinct C.child_id) as `+Docs`
    , count(*) as `+Pages`
    , coalesce(date_format(from_unixtime(mod_time/1000),'%Y-%m-%d %H:%i'),'') as
        `Mod Time` 
from batch B           
   inner join child C using (batch_id)
   inner join page P using (child_id)        
   inner join volume V using(volume_id)
   inner join project PR using (project_id)
   inner join batchuser X on X.batch_id=B.batch_id
   inner join users U on X.coder_id=U.users_id
   left join session S on S.batch_id=B.batch_id
   left join assignment A on A.batch_id=B.batch_id
where U.teams_id=?
  and B.status in ('Unitize', 'UQC', 'Coding', 'CodingQC')
group by B.batch_id
order by U.user_name
   , project_name
   , substring(B.status,1,1)<>'U', B.batch_number

$ report_payroll_detail
SELECT coalesce(U.user_name, '?') as `@User ID`
  , coalesce(V.volume_name, '') as `@Volume`
  , P.project_name as `Project`
  , BC.status as Status
  , BC.field_level as Level
  , if (BC.status like 'U%', concat('U-',BC.batch_number), BC.batch_number)
      as `Batch`
  , BC.child_count as `+Docs`
  , coalesce(CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_doc_price*.1, 0)
                   WHEN 'UQC' THEN coalesce(UP.uqc_doc_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(UP.coding_doc_price*.1, 0)
                   WHEN 'CodingQC' THEN coalesce(UP.codingqc_doc_price*.1, 0) END
             , 0) as '#Doc Price'
  , BC.page_count as `+Pages`
  , coalesce(CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_page_price*.1, 0)
                   WHEN 'UQC' THEN coalesce(UP.uqc_page_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(UP.coding_page_price*.1, 0)
                   WHEN 'CodingQC' THEN coalesce(UP.codingqc_page_price*.1, 0) END
             , 0) as '#Page Price'
  , round( ((CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_page_price*.1, 0)
                   WHEN 'UQC' THEN coalesce(UP.uqc_page_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(UP.coding_page_price*.1, 0)
                   WHEN 'CodingQC' THEN coalesce(UP.codingqc_page_price*.1, 0) END
          * BC.page_count)
          +
          (CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_doc_price*.1, 0)
                   WHEN 'UQC' THEN coalesce(UP.uqc_doc_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(UP.coding_doc_price*.1, 0)
                   WHEN 'CodingQC' THEN coalesce(UP.codingqc_doc_price*.1, 0) END
          * BC.child_count))
          * .01, 2) as '$Amount'
from batchcredit BC
   inner join project P on P.project_id=BC.project_id
   left join volume V on V.volume_id = BC.volume_id
   left join users U on U.users_id = BC.users_id
   left join unitprice UP ON (UP.project_id  = BC.project_id
                         and  UP.volume_id   = BC.volume_id
                         AND  UP.field_level = BC.field_level )
where (BC.credit_time between ? and ?) and not BC.rework
order by U.user_name, P.project_name, V.sequence, BC.field_level, BC.status like 'U%'
  , BC.status, BC.batch_number, BC.credit_time

$ report_payroll_detail_team
SELECT coalesce(U.user_name, '?') as `@User ID`
  , coalesce(V.volume_name, '') as `@Volume`
  , P.project_name as `Project`
  , BC.status as Status
  , BC.field_level as Level
  , if (BC.status like 'U%', concat('U-',BC.batch_number), BC.batch_number)
      as `Batch`
  , BC.child_count as `+Docs`
  , coalesce(CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_doc_price*.1, 0)
                   WHEN 'UQC' THEN coalesce(UP.uqc_doc_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(UP.coding_doc_price*.1, 0)
                   WHEN 'CodingQC' THEN coalesce(UP.codingqc_doc_price*.1, 0) END
             , 0) as '#Doc Price'
  , BC.page_count as `+Pages`
  , coalesce(CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_page_price*.1, 0)
                   WHEN 'UQC' THEN coalesce(UP.uqc_page_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(UP.coding_page_price*.1, 0)
                   WHEN 'CodingQC' THEN coalesce(UP.codingqc_page_price*.1, 0) END
             , 0) as '#Page Price'
  , round( ((CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_page_price*.1, 0)
                   WHEN 'UQC' THEN coalesce(UP.uqc_page_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(UP.coding_page_price*.1, 0)
                   WHEN 'CodingQC' THEN coalesce(UP.codingqc_page_price*.1, 0) END
          * BC.page_count)
          +
          (CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_doc_price*.1, 0)
                   WHEN 'UQC' THEN coalesce(UP.uqc_doc_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(UP.coding_doc_price*.1, 0)
                   WHEN 'CodingQC' THEN coalesce(UP.codingqc_doc_price*.1, 0) END
          * BC.child_count))
          * .01, 2) as '$Amount'
from batchcredit BC
   inner join project P on P.project_id=BC.project_id
   inner join users UT ON UT.users_id = [user]
   inner join users U ON  U.users_id = BC.users_id AND U.teams_id = UT.teams_id
   left join unitprice UP ON (UP.project_id  = BC.project_id
                         and  UP.volume_id   = BC.volume_id
                         AND  UP.field_level = BC.field_level )
   left join volume V on V.volume_id = BC.volume_id
where (BC.credit_time between ? and ?) and not BC.rework
order by U.user_name, P.project_name, V.sequence, BC.field_level, BC.status like 'U%'
  , BC.status, BC.batch_number, BC.credit_time

$ report_payroll_detail_user
SELECT coalesce(V.volume_name, '') as `@Volume`
  , P.project_name as `Project`
  , BC.status as Status
  , BC.field_level as Level
  , if (BC.status like 'U%', concat('U-',BC.batch_number), BC.batch_number)
      as `Batch`
  , BC.child_count as `+Docs`
  , coalesce(CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_doc_price*.1, 0)
                   WHEN 'UQC' THEN coalesce(UP.uqc_doc_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(UP.coding_doc_price*.1, 0)
                   WHEN 'CodingQC' THEN coalesce(UP.codingqc_doc_price*.1, 0) END
             , 0) as '#Doc Price'
  , BC.page_count as `+Pages`
  , coalesce(CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_page_price*.1, 0)
                   WHEN 'UQC' THEN coalesce(UP.uqc_page_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(UP.coding_page_price*.1, 0)
                   WHEN 'CodingQC' THEN coalesce(UP.codingqc_page_price*.1, 0) END
             , 0) as '#Page Price'
  , round( ((CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_page_price*.1, 0)
                   WHEN 'UQC' THEN coalesce(UP.uqc_page_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(UP.coding_page_price*.1, 0)
                   WHEN 'CodingQC' THEN coalesce(UP.codingqc_page_price*.1, 0) END
          * BC.page_count)
          +
          (CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_doc_price*.1, 0)
                   WHEN 'UQC' THEN coalesce(UP.uqc_doc_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(UP.coding_doc_price*.1, 0)
                   WHEN 'CodingQC' THEN coalesce(UP.codingqc_doc_price*.1, 0) END
          * BC.child_count))
          * .01, 2) as '$Amount'
from batchcredit BC
   inner join project P on P.project_id=BC.project_id
   left join users U on U.users_id = BC.users_id
   left join unitprice UP ON (UP.project_id  = BC.project_id
                         and  UP.volume_id   = BC.volume_id
                         AND  UP.field_level = BC.field_level )
   left join volume V on V.volume_id = BC.volume_id
where (BC.credit_time between ? and ?) and (BC.users_id = [user]) and not BC.rework
order by U.user_name, P.project_name, V.sequence, BC.field_level, BC.status like 'U%'
  , BC.status, BC.batch_number, BC.credit_time

$ report_payroll_summary
SELECT coalesce(U.user_name, '?') as `@User ID`
  , coalesce(V.volume_name, '') as `@Volume`
  , P.project_name as `Project`
  , BC.status as Status
  , BC.field_level as Level
  , sum(BC.child_count) as `+Docs`
  , coalesce(CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_doc_price*.1, 0)
                   WHEN 'UQC' THEN coalesce(UP.uqc_doc_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(UP.coding_doc_price*.1, 0)
                   WHEN 'CodingQC' THEN coalesce(UP.codingqc_doc_price*.1, 0) END
             , 0) as '#Doc Price'
  , sum(BC.page_count) as `+Pages`
  , coalesce(CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_page_price*.1, 0)
                   WHEN 'UQC' THEN coalesce(UP.uqc_page_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(UP.coding_page_price*.1, 0)
                   WHEN 'CodingQC' THEN coalesce(UP.codingqc_page_price*.1, 0) END
             , 0) as '#Page Price'
  , sum(round( ((CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_page_price*.1, 0)
                   WHEN 'UQC' THEN coalesce(UP.uqc_page_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(UP.coding_page_price*.1, 0)
                   WHEN 'CodingQC' THEN coalesce(UP.codingqc_page_price*.1, 0) END
          * BC.page_count)
          +
          (CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_doc_price*.1, 0)
                   WHEN 'UQC' THEN coalesce(UP.uqc_doc_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(UP.coding_doc_price*.1, 0)
                   WHEN 'CodingQC' THEN coalesce(UP.codingqc_doc_price*.1, 0) END
          * BC.child_count))
          * .01, 2)) as '$Amount'
from batchcredit BC
   inner join project P on P.project_id=BC.project_id
   left join volume V on V.volume_id = BC.volume_id
   left join users U on U.users_id = BC.users_id
   left join unitprice UP ON (UP.project_id  = BC.project_id
                         and  UP.volume_id   = BC.volume_id
                         AND  UP.field_level = BC.field_level )
where (BC.credit_time between ? and ?) and not BC.rework
group by U.user_name, V.sequence, P.project_name, BC.field_level, BC.status like 'U%'
  , BC.status
order by U.user_name, P.project_name, V.sequence, BC.field_level, BC.status like 'U%'
  , BC.status, BC.batch_number, BC.credit_time

$ report_payroll_summary_team
SELECT coalesce(U.user_name, '?') as `@User ID`
  , coalesce(V.volume_name, '') as `@Volume`
  , P.project_name as `Project`
  , BC.status as Status
  , BC.field_level as Level
  , sum(BC.child_count) as `+Docs`
  , coalesce(CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_doc_price*.1, 0)
                   WHEN 'UQC' THEN coalesce(UP.uqc_doc_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(UP.coding_doc_price*.1, 0)
                   WHEN 'CodingQC' THEN coalesce(UP.codingqc_doc_price*.1, 0) END
             , 0) as '#Doc Price'
  , sum(BC.page_count) as `+Pages`
  , coalesce(CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_page_price*.1, 0)
                   WHEN 'UQC' THEN coalesce(UP.uqc_page_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(UP.coding_page_price*.1, 0)
                   WHEN 'CodingQC' THEN coalesce(UP.codingqc_page_price*.1, 0) END
             , 0) as '#Page Price'
  , sum(round( ((CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_page_price*.1, 0)
                   WHEN 'UQC' THEN coalesce(UP.uqc_page_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(UP.coding_page_price*.1, 0)
                   WHEN 'CodingQC' THEN coalesce(UP.codingqc_page_price*.1, 0) END
          * BC.page_count)
          +
          (CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_doc_price*.1, 0)
                   WHEN 'UQC' THEN coalesce(UP.uqc_doc_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(UP.coding_doc_price*.1, 0)
                   WHEN 'CodingQC' THEN coalesce(UP.codingqc_doc_price*.1, 0) END
          * BC.child_count))
          * .01, 2)) as '$Amount'
from batchcredit BC
   inner join project P on P.project_id=BC.project_id
   inner join users UT ON UT.users_id = [user]
   inner join users U ON  U.users_id = BC.users_id AND U.teams_id = UT.teams_id
   left join volume V on V.volume_id = BC.volume_id
   left join unitprice UP ON (UP.project_id  = BC.project_id
                         and  UP.volume_id   = BC.volume_id
                         AND  UP.field_level = BC.field_level )
where (BC.credit_time between ? and ?) and not BC.rework
group by U.user_name, V.sequence, P.project_name, BC.field_level, BC.status like 'U%'
  , BC.status
order by U.user_name, P.project_name, V.sequence, BC.field_level, BC.status like 'U%'
  , BC.status, BC.batch_number, BC.credit_time

$ report_payroll_summary_user
SELECT coalesce(V.volume_name, '') as `@Volume`
  , P.project_name as `Project`
  , BC.status as Status
  , BC.field_level as Level
  , sum(BC.child_count) as `+Docs`
  , coalesce(CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_doc_price*.1, 0)
                   WHEN 'UQC' THEN coalesce(UP.uqc_doc_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(UP.coding_doc_price*.1, 0)
                   WHEN 'CodingQC' THEN coalesce(UP.codingqc_doc_price*.1, 0) END
             , 0) as '#Doc Price'
  , sum(BC.page_count) as `+Pages`
  , coalesce(CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_page_price*.1, 0)
                   WHEN 'UQC' THEN coalesce(UP.uqc_page_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(UP.coding_page_price*.1, 0)
                   WHEN 'CodingQC' THEN coalesce(UP.codingqc_page_price*.1, 0) END
             , 0) as '#Page Price'
  , sum(round( ((CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_page_price*.1, 0)
                   WHEN 'UQC' THEN coalesce(UP.uqc_page_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(UP.coding_page_price*.1, 0)
                   WHEN 'CodingQC' THEN coalesce(UP.codingqc_page_price*.1, 0) END
          * BC.page_count)
          +
          (CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_doc_price*.1, 0)
                   WHEN 'UQC' THEN coalesce(UP.uqc_doc_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(UP.coding_doc_price*.1, 0)
                   WHEN 'CodingQC' THEN coalesce(UP.codingqc_doc_price*.1, 0) END
          * BC.child_count))
          * .01, 2)) as '$Amount'
from batchcredit BC
   inner join project P on P.project_id=BC.project_id
   left join volume V on V.volume_id = BC.volume_id
   left join users U on U.users_id = BC.users_id
   left join unitprice UP ON (UP.project_id  = BC.project_id
                         and  UP.volume_id   = BC.volume_id
                         AND  UP.field_level = BC.field_level )
where (BC.credit_time between ? and ?) and (BC.users_id = [user]) and not BC.rework
group by U.user_name, V.sequence, P.project_name, BC.field_level, BC.status like 'U%'
  , BC.status
order by U.user_name, P.project_name, V.sequence, BC.field_level, BC.status like 'U%'
  , BC.status, BC.batch_number, BC.credit_time

$report_payroll_project_volume_status
SELECT P.project_name as `@Project`
  , coalesce(V.volume_name, '?') AS `@Volume`
  , BC.status as Status
  , BC.field_level as Level
  , sum(BC.child_count) as `+Docs`
  , coalesce(CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_doc_price*.1, 0)
                   WHEN 'UQC' THEN coalesce(UP.uqc_doc_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(UP.coding_doc_price*.1, 0)
                   WHEN 'CodingQC' THEN coalesce(UP.codingqc_doc_price*.1, 0) END
             , 0) as '#Doc Price'
  , sum(BC.page_count) as `+Pages`
  , coalesce(CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_page_price*.1, 0)
                   WHEN 'UQC' THEN coalesce(UP.uqc_page_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(UP.coding_page_price*.1, 0)
                   WHEN 'CodingQC' THEN coalesce(UP.codingqc_page_price*.1, 0) END
             , 0) as '#Page Price'
  , sum(round( ((CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_page_price*.1, 0)
                   WHEN 'UQC' THEN coalesce(UP.uqc_page_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(UP.coding_page_price*.1, 0)
                   WHEN 'CodingQC' THEN coalesce(UP.codingqc_page_price*.1, 0) END
          * BC.page_count)
          +
          (CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_doc_price*.1, 0)
                   WHEN 'UQC' THEN coalesce(UP.uqc_doc_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(UP.coding_doc_price*.1, 0)
                   WHEN 'CodingQC' THEN coalesce(UP.codingqc_doc_price*.1, 0) END
          * BC.child_count))
          * .01, 2)) as '$Amount'
from batchcredit BC
   inner join project P on P.project_id=BC.project_id
   left join volume V on V.volume_id = BC.volume_id
   left join users U on U.users_id = BC.users_id
   left join unitprice UP ON (UP.project_id  = BC.project_id
                         and  UP.volume_id   = BC.volume_id
                         AND  UP.field_level = BC.field_level )
where (BC.credit_time between ? and ?) and not BC.rework
group by P.project_name, V.sequence, BC.status like 'U%'
  , BC.status, BC.field_level
order by P.project_name, V.sequence, BC.field_level, BC.status like 'U%'
  , BC.status, BC.batch_number, BC.credit_time

$ report_payroll_user_project_status
SELECT coalesce(U.user_name, '?') as `@User ID`
  , P.project_name as `@Project`
  , BC.status as Status
  , BC.field_level as Level
  , sum(BC.child_count) as `+Docs`
  , sum(BC.page_count) as `+Pages`
  , sum(round( ((CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_page_price*.1, 0)
                   WHEN 'UQC' THEN coalesce(UP.uqc_page_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(UP.coding_page_price*.1, 0)
                   WHEN 'CodingQC' THEN coalesce(UP.codingqc_page_price*.1, 0) END
          * BC.page_count)
          +
          (CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_doc_price*.1, 0)
                   WHEN 'UQC' THEN coalesce(UP.uqc_doc_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(UP.coding_doc_price*.1, 0)
                   WHEN 'CodingQC' THEN coalesce(UP.codingqc_doc_price*.1, 0) END
          * BC.child_count))
          * .01, 2)) as '$Amount'
from batchcredit BC
   inner join project P on P.project_id=BC.project_id
   left join users U on U.users_id = BC.users_id
   left join unitprice UP ON (UP.project_id  = BC.project_id
                         and  UP.volume_id   = BC.volume_id
                         AND  UP.field_level = BC.field_level )
where (BC.credit_time between ? and ?) and not BC.rework
group by U.user_name, P.project_name, BC.field_level, BC.status like 'U%'
  , BC.status
order by U.user_name, P.project_name, BC.field_level, BC.status like 'U%'
  , BC.status, BC.batch_number, BC.credit_time

$ report_profit_detail
 SELECT DISTINCT U.user_name as '@User'
  , P.project_name as `@Project`
  , coalesce(V.volume_name, '') as `Volume`
  , if (BC.status like 'U%', concat('U-',BC.batch_number), BC.batch_number)
      as `Batch`
  , BC.status as Status
  , BC.field_level as Level
  , sum(BC.child_count) as `+Docs Paid`
  , sum(BC.page_count) as `+Pages Paid`
  , sum(round( ((CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_page_price*.1, 0)
                   WHEN 'UQC' THEN coalesce(UP.uqc_page_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(UP.coding_page_price*.1, 0)
                   WHEN 'CodingQC' THEN coalesce(UP.codingqc_page_price*.1, 0) END
          * BC.page_count)
          +
          (CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_doc_price*.1, 0)
                   WHEN 'UQC' THEN coalesce(UP.uqc_doc_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(UP.coding_doc_price*.1, 0)
                   WHEN 'CodingQC' THEN coalesce(UP.codingqc_doc_price*.1, 0) END
          * BC.child_count))
          * .01, 2)) as '$Amount Paid'
  , sum(CASE BC.status WHEN 'Unitize' THEN BC.child_count
                       WHEN 'Coding' THEN BC.child_count ELSE 0 END) as `+Docs Rcv`
  , sum(CASE BC.status WHEN 'Unitize' THEN BC.page_count
                       WHEN 'Coding' THEN BC.page_count ELSE 0 END) as `+Pages Rcv`
  , sum(round( ((CASE BC.status WHEN 'Unitize' THEN coalesce(CP.unitize_page_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(CP.coding_page_price*.1, 0) ELSE 0 END
          * BC.page_count)
          +
          (CASE BC.status WHEN 'Unitize' THEN coalesce(CP.unitize_doc_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(CP.coding_doc_price*.1, 0) ELSE 0 END
          * BC.child_count))
          * .01, 2)) as '$Receivable'
  , coalesce(round( (
          SUM(( ((CASE BC.status WHEN 'Unitize' THEN coalesce(CP.unitize_page_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(CP.coding_page_price*.1, 0) ELSE 0 END
          * BC.page_count)
          +
          (CASE BC.status WHEN 'Unitize' THEN coalesce(CP.unitize_doc_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(CP.coding_doc_price*.1, 0) ELSE 0 END
          * BC.child_count))
          -
          ((CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_page_price*.1, 0)
                           WHEN 'UQC' THEN coalesce(UP.uqc_page_price*.1, 0)
                           WHEN 'Coding' THEN coalesce(UP.coding_page_price*.1, 0)
                           WHEN 'CodingQC' THEN coalesce(UP.codingqc_page_price*.1, 0) END
                  * BC.page_count)
                  +
                  (CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_doc_price*.1, 0)
                           WHEN 'UQC' THEN coalesce(UP.uqc_doc_price*.1, 0)
                           WHEN 'Coding' THEN coalesce(UP.coding_doc_price*.1, 0)
                           WHEN 'CodingQC' THEN coalesce(UP.codingqc_doc_price*.1, 0) END
                  * BC.child_count))))
          * .01), 2),0) as '%Gross Margin %'
  , sum(round( ( ((CASE BC.status WHEN 'Unitize' THEN coalesce(CP.unitize_page_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(CP.coding_page_price*.1, 0) ELSE 0 END
          * BC.page_count)
          +
          (CASE BC.status WHEN 'Unitize' THEN coalesce(CP.unitize_doc_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(CP.coding_doc_price*.1, 0) ELSE 0 END
          * BC.child_count))
          -
          ((CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_page_price*.1, 0)
                           WHEN 'UQC' THEN coalesce(UP.uqc_page_price*.1, 0)
                           WHEN 'Coding' THEN coalesce(UP.coding_page_price*.1, 0)
                           WHEN 'CodingQC' THEN coalesce(UP.codingqc_page_price*.1, 0) END
                  * BC.page_count)
                  +
                  (CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_doc_price*.1, 0)
                           WHEN 'UQC' THEN coalesce(UP.uqc_doc_price*.1, 0)
                           WHEN 'Coding' THEN coalesce(UP.coding_doc_price*.1, 0)
                           WHEN 'CodingQC' THEN coalesce(UP.codingqc_doc_price*.1, 0) END
                  * BC.child_count)))
          * .01, 2)) as '$Gross Margin'
from batchcredit BC
   inner join project P on P.project_id=BC.project_id
   left join volume V on V.volume_id = BC.volume_id
   left join users U on U.users_id = BC.users_id
   left join unitprice UP ON (UP.project_id  = BC.project_id
                         and  UP.volume_id   = BC.volume_id
                         AND  UP.field_level = BC.field_level )
   left join customerprice CP ON (CP.project_id  = BC.project_id
                         and  CP.volume_id   = BC.volume_id
                         AND  CP.field_level = BC.field_level )
where (BC.credit_time between ? and ?) and not BC.rework
group by U.users_id, P.project_id, V.sequence, BC.batch_number, BC.status, BC.field_level
order by U.user_name, P.project_id, V.sequence, BC.batch_number, BC.status, BC.field_level, BC.credit_time

$ report_profit_summary
 SELECT DISTINCT P.project_name as `@Project`
  , coalesce(V.volume_name, '') as `@Volume`
  , if (BC.status like 'U%', concat('U-',BC.batch_number), BC.batch_number)
      as `Batch`
  , BC.field_level as Level
  , sum(BC.child_count) as `+Docs Paid`
  , sum(BC.page_count) as `+Pages Paid`
  , sum(round( ((CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_page_price*.1, 0)
                   WHEN 'UQC' THEN coalesce(UP.uqc_page_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(UP.coding_page_price*.1, 0)
                   WHEN 'CodingQC' THEN coalesce(UP.codingqc_page_price*.1, 0) END
          * BC.page_count)
          +
          (CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_doc_price*.1, 0)
                   WHEN 'UQC' THEN coalesce(UP.uqc_doc_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(UP.coding_doc_price*.1, 0)
                   WHEN 'CodingQC' THEN coalesce(UP.codingqc_doc_price*.1, 0) END
          * BC.child_count))
          * .01, 2)) as '$Amount Paid'
  , sum(CASE BC.status WHEN 'Unitize' THEN BC.child_count
                       WHEN 'Coding' THEN BC.child_count ELSE 0 END) as `+Docs Rcv`
  , sum(CASE BC.status WHEN 'Unitize' THEN BC.page_count
                       WHEN 'Coding' THEN BC.page_count ELSE 0 END) as `+Pages Rcv`
  , sum(round( ((CASE BC.status WHEN 'Unitize' THEN coalesce(CP.unitize_page_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(CP.coding_page_price*.1, 0) ELSE 0 END
          * BC.page_count)
          +
          (CASE BC.status WHEN 'Unitize' THEN coalesce(CP.unitize_doc_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(CP.coding_doc_price*.1, 0) ELSE 0 END
          * BC.child_count))
          * .01, 2)) as '$Receivable'
  , coalesce(round( (
          SUM(( ((CASE BC.status WHEN 'Unitize' THEN coalesce(CP.unitize_page_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(CP.coding_page_price*.1, 0) ELSE 0 END
          * BC.page_count)
          +
          (CASE BC.status WHEN 'Unitize' THEN coalesce(CP.unitize_doc_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(CP.coding_doc_price*.1, 0) ELSE 0 END
          * BC.child_count))
          -
          ((CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_page_price*.1, 0)
                           WHEN 'UQC' THEN coalesce(UP.uqc_page_price*.1, 0)
                           WHEN 'Coding' THEN coalesce(UP.coding_page_price*.1, 0)
                           WHEN 'CodingQC' THEN coalesce(UP.codingqc_page_price*.1, 0) END
                  * BC.page_count)
                  +
                  (CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_doc_price*.1, 0)
                           WHEN 'UQC' THEN coalesce(UP.uqc_doc_price*.1, 0)
                           WHEN 'Coding' THEN coalesce(UP.coding_doc_price*.1, 0)
                           WHEN 'CodingQC' THEN coalesce(UP.codingqc_doc_price*.1, 0) END
                  * BC.child_count))))
          * .01), 2),0) as '%Gross Margin %'
  , sum(round( ( ((CASE BC.status WHEN 'Unitize' THEN coalesce(CP.unitize_page_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(CP.coding_page_price*.1, 0) ELSE 0 END
          * BC.page_count)
          +
          (CASE BC.status WHEN 'Unitize' THEN coalesce(CP.unitize_doc_price*.1, 0)
                   WHEN 'Coding' THEN coalesce(CP.coding_doc_price*.1, 0) ELSE 0 END
          * BC.child_count))
          -
          ((CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_page_price*.1, 0)
                           WHEN 'UQC' THEN coalesce(UP.uqc_page_price*.1, 0)
                           WHEN 'Coding' THEN coalesce(UP.coding_page_price*.1, 0)
                           WHEN 'CodingQC' THEN coalesce(UP.codingqc_page_price*.1, 0) END
                  * BC.page_count)
                  +
                  (CASE BC.status WHEN 'Unitize' THEN coalesce(UP.unitize_doc_price*.1, 0)
                           WHEN 'UQC' THEN coalesce(UP.uqc_doc_price*.1, 0)
                           WHEN 'Coding' THEN coalesce(UP.coding_doc_price*.1, 0)
                           WHEN 'CodingQC' THEN coalesce(UP.codingqc_doc_price*.1, 0) END
                  * BC.child_count)))
          * .01, 2)) as '$Gross Margin'
from batchcredit BC
   inner join project P on P.project_id=BC.project_id
   left join volume V on V.volume_id = BC.volume_id
   left join unitprice UP ON (UP.project_id  = BC.project_id
                         and  UP.volume_id   = BC.volume_id
                         AND  UP.field_level = BC.field_level )
   left join customerprice CP ON (CP.project_id  = BC.project_id
                         and  CP.volume_id   = BC.volume_id
                         AND  CP.field_level = BC.field_level )
where (BC.credit_time between ? and ?) and not BC.rework
group by P.project_id, V.sequence, BC.batch_number, BC.field_level
order by P.project_id, V.sequence, BC.batch_number, BC.field_level, BC.status, BC.credit_time

$ report_qc_batch_team
select PR.project_name as `@Project`
    , if(substring(B.status,1,1)='U', concat('U-',B.batch_number), B.batch_number)
        as `Batch`       
    , B.status as `Status` 
    , case 
        when S.batch_id is not null then 'In Use' 
        when A.batch_id is not null then 'Assigned' 
        else '' end as `Asg/Use`
    , if(X.rework,'YES','') as Rework
    , count(distinct C.child_id) as `+Docs`
    , count(*) as `+Pages`
    , U.user_name as `Coder Id`  
    , coalesce(date_format(from_unixtime(mod_time/1000),'%Y-%m-%d %H:%i'),'')
        as `Mod Time` 
from batch B           
   inner join child C using (batch_id)
   inner join page P using (child_id)        
   inner join volume V using(volume_id)
   inner join project PR using (project_id)
   inner join batchuser X on X.batch_id=B.batch_id
   inner join users U on X.coder_id=U.users_id
   left join session S on S.batch_id=B.batch_id
   left join assignment A on A.batch_id=B.batch_id
where U.teams_id=?
   and B.status = 'CodingQC'
group by B.batch_id
order by project_name, substring(B.status,1,1)<>'U', B.batch_number

$ report_qc_batch_team_by_coder
select coalesce(U.user_name,'')  as `@Coder Id`  
    , PR.project_name as `Project`
    , if(substring(B.status,1,1)='U', concat('U-',B.batch_number), B.batch_number)
        as `Batch`       
    , B.status as `Status` 
    , case 
        when S.batch_id is not null then 'In Use' 
        when A.batch_id is not null then 'Assigned' 
        else '' end as `Asg/Use`
    , if(X.rework,'YES','') as Rework
    , count(distinct C.child_id) as `+Docs`
    , count(*) as `+Pages`
    , coalesce(date_format(from_unixtime(mod_time/1000),'%Y-%m-%d %H:%i'),'')
        as `Mod Time` 
from batch B           
   inner join child C using (batch_id)
   inner join page P using (child_id)        
   inner join volume V using(volume_id)
   inner join project PR using (project_id)
   inner join batchuser X on X.batch_id=B.batch_id
   inner join users U on X.coder_id=U.users_id
   left join session S on S.batch_id=B.batch_id
   left join assignment A on A.batch_id=B.batch_id
where U.teams_id=?
   and B.status = 'CodingQC'
group by B.batch_id
order by U.user_name
   , project_name
   , substring(B.status,1,1)<>'U', B.batch_number

$ report_stale_batch
select PR.project_name as `@Project`
    , if(substring(B.status,1,1)='U', concat('U-',B.batch_number), B.batch_number)
        as `Batch`       
    , B.status as `Status` 
    , case 
        when S.batch_id is not null then 'In Use' 
        when A.batch_id is not null then 'Assigned' 
        else '' end as `Asg/Use`
    , if(X.rework,'YES','') as Rework
    , count(distinct C.child_id) as `+Docs`
    , count(*) as `+Pages`
    , coalesce(U.user_name,'')  as `Coder Id`  
    , coalesce(T.team_name,'')  as `Team`  
    , coalesce(date_format(from_unixtime(mod_time/1000),'%Y-%m-%d %H:%i'),'')
        as `Mod Time` 
from batch B           
   inner join child C using (batch_id)
   inner join page P using (child_id)        
   inner join volume V using(volume_id)
   inner join project PR using (project_id)
   inner join batchuser X on X.batch_id=B.batch_id
   inner join users U on X.coder_id=U.users_id
   inner join teams T using (teams_id)
   left join session S on S.batch_id=B.batch_id
   left join assignment A on A.batch_id=B.batch_id
where B.status in ('Unitize', 'UQC', 'Coding', 'CodingQC')
   and X.mod_time < 1000*unix_timestamp(date_sub(current_date, interval (? - 1) day))
group by B.batch_id
order by project_name, substring(B.status,1,1)<>'U', B.batch_number

$ report_summary_project
select V.volume_name as `@Volume`
    , B.active_group as 'Group'
    , if(B.status='QCComplete', 'QA', B.status) as Status
    , count(distinct C.child_id) as `+Documents`
    , count(*) as `+Pages`
    , V.image_path as `Image Path`
from volume V
    inner join batch B using (volume_id)
    inner join child C using (batch_id)
    inner join page P using (child_id)
where V.project_id = ?
    and V.sequence > 0
    and B.status <> 'UBatched'
group by V.volume_name, B.active_group, B.Status
order by V.volume_name, B.active_group, B.status

$ report_timesheet
select U.user_name as '@User'
, P.project_name as `@Project`
, V.volume_name as `Volume`
, B.batch_number as 'Batch'
, E.status as 'Status'
, substring(FROM_UNIXTIME(E.open_timestamp/1000),1,10) as 'Date'
, substring(FROM_UNIXTIME(E.open_timestamp/1000),12,5) as 'Start Time'
, if(E.close_timestamp=0 or E.close_timestamp = 2147483647,
          substring(FROM_UNIXTIME(E.add_timestamp/1000),12,5),
          substring(FROM_UNIXTIME(E.close_timestamp/1000),12,5)) as 'End Time'
, DATE_FORMAT(concat('0000-00-00 0', .01 *
    (if( DATE_FORMAT(FROM_UNIXTIME(E.open_timestamp/1000),'%i')
    >
     if(E.close_timestamp=0 or E.close_timestamp = 2147483647,
        DATE_FORMAT(FROM_UNIXTIME(E.add_timestamp/1000),'%i'),
        DATE_FORMAT(FROM_UNIXTIME(E.close_timestamp/1000),'%i'))
        , (if(E.close_timestamp=0 or E.close_timestamp = 2147483647,
            DATE_FORMAT(FROM_UNIXTIME(E.add_timestamp/1000),'%H%i')+0,
            DATE_FORMAT(FROM_UNIXTIME(E.close_timestamp/1000),'%H%i')+0)
            -
            DATE_FORMAT(FROM_UNIXTIME(E.open_timestamp/1000),'%H%i')+0
            - 40)
              ,  (if(E.close_timestamp=0 or E.close_timestamp = 2147483647,
                DATE_FORMAT(FROM_UNIXTIME(E.add_timestamp/1000),'%H%i')+0,
                DATE_FORMAT(FROM_UNIXTIME(E.close_timestamp/1000),'%H%i')+0)
                -
                DATE_FORMAT(FROM_UNIXTIME(E.open_timestamp/1000),'%H%i')+0
                )+0 )+0
    )+0), '%k:%i'
  )
  as 'Elapsed Time'
, if(E.close_timestamp=0,'Incomplete','Complete') as 'Progress'
, E.child_count as `+Docs`
, E.page_count as `+Pages`
, E.field_count as `+Fields`
from event E
  inner join users U on (U.users_id=E.users_id)
  inner join volume V on (V.volume_id=E.volume_id)
  inner join project P on (P.project_id=V.project_id)
  left join batch B on (B.batch_id=E.batch_id)
where (E.open_timestamp between ? and ?
    or E.add_timestamp between ? and ?)
      and (E.child_count > 0
        or E.page_count > 0
        or E.field_count > 0)
order by U.users_id, E.open_timestamp
, P.project_name, V.volume_name, B.batch_number

$ server_date_millis
select 1000*unix_timestamp(current_date())

$ session_coder_name
select U.user_name
from users U
  inner join batchuser BU
    on BU.coder_id = U.users_id
where BU.batch_id = ?

$ session_error_rates
select substring(from_unixtime(BE.credit_time/1000),1,16) as `Time Closed`,
   user_name as User,
   if(rework, 'Yes', 'No') as `Rework`,
   field_count as `Fields Coded`,
   if(change_count = 0, 0, if(field_count = 0, 0, FORMAT(((change_count*100+.5)/field_count), 1))) as `Pct Changed`,
   if(error_count = 0, 0, if(field_count = 0, 0, FORMAT(((error_count*100+.5)/field_count), 1))) as `Pct Errors`
from batcherror BE
   inner join users U using (users_id)
where BE.batch_id=?
order by BE.credit_time, U.user_name

$ session_qa_error_rates
select substring(from_unixtime(VE.credit_time/1000),1,16) as `Time Closed`,
   user_name as User,
   coalesce(T.team_name, '') as Team,
   if(rework, 'Yes', 'No') as `Rework`,
   field_count,
   change_count,
   error_count
from volumeerror VE
   inner join users U using (users_id)
   left join teams T using (teams_id)
where VE.volume_id=[volume]
order by Team, VE.rework, VE.credit_time, U.user_name

$ session_statistics
select substring(from_unixtime(BC.credit_time/1000),1,16) as Time
  , U.user_name as User
  , if(BC.rework,'YES','') as `Rework`
  , BC.field_level as Level
  , BC.active_group as 'Group'
  , BC.child_count as Docs
  , BC.page_count as Pages
from batchcredit BC
  inner join users U using (users_id)
where batch_id=?
  and status=?
order by BC.credit_time, U.user_name

$ SessionAdminPage.sessionTable
select session_id, session_id, server_nbr, U.user_name,
  concat(U.first_name,' ',U.last_name) as User,
  T.team_name, concat(L.first_name,' ',L.last_name) as Leader,
  trim(concat(case
        when S.is_admin then 'Admin'
        when S.batch_id > 0 then concat(P.project_name,if(substring(B.status,1,1)='U',' U-',' '),B.batch_number,' ',B.status)
        when S.volume_id > 0 then concat(P.project_name,' ',V.volume_name,' QA')
        else '' end
    , ' ',if(S.live,'','Disconnected'))) as Remarks
from session S
  inner join users U on S.users_id=U.users_id
  left join teams T on U.teams_id=T.teams_id
  left join users L on T.users_id=L.users_id
  left join batch B on S.batch_id > 0 and B.batch_id = S.batch_id
  left join volume V on S.volume_id > 0 and V.volume_id = S.volume_id
  left join project P using (project_id)

$ SessionAdminPage.sessionTableTL
select session_id, session_id, server_nbr, U.user_name,
  concat(U.first_name,' ',U.last_name) as User,
  T.team_name, concat(L.first_name,' ',L.last_name) as Leader,
  trim(concat(case
        when S.is_admin then 'Admin'
        when S.batch_id > 0 then concat(P.project_name,if(substring(B.status,1,1)='U',' U-',' '),B.batch_number,' ',B.status)
        when S.volume_id > 0 then concat(P.project_name,' ',V.volume_name,' QA')
        else '' end
    , ' ',if(S.live,'','Disconnected'))) as Remarks
from session S
  inner join users U on S.users_id=U.users_id
  inner join teams T on U.teams_id=T.teams_id
  inner join users L on T.users_id=L.users_id
  left join batch B on S.batch_id > 0 and B.batch_id = S.batch_id
  left join volume V on S.volume_id > 0 and V.volume_id = S.volume_id
  left join project P using (project_id)
where T.users_id=[user]

$ SplitPaneViewer.closeMenuItem
update session set volume_id=0, batch_id=0, lock_time=0
 where session_id=[task]
 
$ SplitPaneViewer.get users status
select user_name, team_name, if(uqc = 'Yes' or codingqc = 'Yes' or team_leader = 'Yes', 1, 0)
from users U
left join teams using (teams_id)
where U.users_id=[user]

$ SplitPaneViewer.tablespec
select TS.tablespec_id, TS.table_name, TS.table_type, TS.updateable, TS.project_id
 from tablespec TS
 where TS.project_id in (?, 0)

$ SplitPaneViewer.tablevalue
select TV.tablevalue_id, TV.value, TV.tablespec_id, TV.field_level, TV.model_value, PF.field_name
 from tablevalue TV
   left join tablespec TS using (tablespec_id)
   left join projectfields PF on (PF.tablespec_id = TS.model_tablespec_id)
 where TS.project_id = ?

$ SplitPaneViewer.tablevalueGlobal
select TV.tablevalue_id, TV.value, TV.tablespec_id, TV.field_level                                       
 from tablevalue TV, tablespec TS
 where TS.tablespec_id = ? and TS.tablespec_id = TV.tablespec_id

$ TableAdminPage.tablespecTable
select TS.tablespec_id, TS.table_name, TS.table_type
  , IFNULL(P.project_name,'<All Projects>'), TS.requirement, TS.updateable
  , MODEL.table_name, TS.project_id, TS.model_tablespec_id
from tablespec TS
  left join project P using (project_id)
  left join tablespec MODEL on (MODEL.tablespec_id = TS.model_tablespec_id)

$ TableAdminPage.tablespecTableTL
select TS.tablespec_id, TS.table_name, TS.table_type
  , P.project_name, TS.requirement, TS.updateable
  , MODEL.table_name, TS.project_id, TS.model_tablespec_id
from tablespec TS
  inner join project P using (project_id)
  inner join volume V using (project_id)
  inner join teamsvolume TV using (volume_id)
  inner join users U using (teams_id)
  left join tablespec MODEL on (MODEL.tablespec_id = TS.model_tablespec_id)
where users_id=[user]
group by TS.tablespec_id

$ tablespec select
select TS.table_name, TS.table_type, P.project_name, TS.requirement
  , TS.updateable, MODEL.table_name
from tablespec TS
  left join project P using (project_id)
  left join tablespec MODEL on (MODEL.tablespec_id = TS.model_tablespec_id)
  where TS.tablespec_id = ?

$ tablevalue select
select TV.tablevalue_id, TV.model_value, TV.value, TV.field_level
  from tablevalue TV, tablespec TS
WHERE TS.tablespec_id = ?
    AND TS.tablespec_id = TV.tablespec_id

$ TeamAdminPage.teams
select T.teams_id,T.team_name, U.user_name
from teams T
  left join users U on T.users_id = U.users_id

$ TeamAdminPage.unassignedUsers
select users_id, user_name from users
where teams_id=0 and active

$ TeamAdminPage.users
select users_id, user_name from users
where teams_id=? and active

$ teams by id select
select team_name, users_id from teams
where teams_id = ?

$ teamsqueue delete
delete from teamsqueue where batch_id = ? and teams_id = ?

$ teamsvolume delete
delete from teamsvolume where volume_id = ? and teams_id = ?

$ unitprice defaults
select unitize_page_price*.1, unitize_doc_price*.1, uqc_page_price*.1, uqc_doc_price*.1
  , coding_page_price*.1, coding_doc_price*.1, codingqc_page_price*.1, codingqc_doc_price*.1
from unitprice
where project_id = ? and volume_id = 0 and field_level = ?

$ unitprice level defaults
select unitize_page_price*.1, unitize_doc_price*.1, uqc_page_price*.1, uqc_doc_price*.1
  , coding_page_price*.1, coding_doc_price*.1, codingqc_page_price*.1, codingqc_doc_price*.1
from unitprice
where project_id = ? and volume_id = 0 and field_level = 0

$ UserAdminPage.usersTable
select U.users_id, user_name, concat(first_name,' ',last_name), unitize, uqc
  , coding, codingqc, qa, team_leader, admin, T.team_name 
from users U
 left join teams T on (U.teams_id=T.teams_id)
where U.active

$ UserBatching.assignments
select A.assignment_id, P.project_name, B.batch_number
     , B.status, B.status + 0, B.batch_id, B.active_group                                  
from assignment A                                    
  inner join batch B using (batch_id)                
  inner join volume V on V.volume_id = B.volume_id   
  inner join project P on P.project_id = V.project_id
where A.users_id = ?                               

$ UserBatching.teamsTL
select T.teams_id,T.team_name, U.user_name
from teams T
  inner join users U0 using(teams_id)
  left join users U on T.users_id = U.users_id and U.active
where U0.users_id=[user]
group by T.teams_id

$ UserBatching.users
select U.users_id,U.user_name, T.team_name                 
from users U
  left join teams T on U.teams_id = T.teams_id
where U.active

$ UserBatching.usersTL
select U.users_id,U.user_name, T.team_name                 
from users U
  inner join users U0 using (teams_id)
  inner join teams T using (teams_id)
where U.active
  and U0.users_id=[user]
group by U.users_id

$ UserBatching.usersbatchqueue
select UQ.usersqueue_id, P.project_name, B.batch_number
  , B.status, - B.priority, UQ.users_id, UQ.batch_id, B.active_group   
from usersqueue UQ                                     
  inner join users U using (users_id)                  
  inner join batch B on UQ.batch_id=B.batch_id         
  inner join volume V on V.volume_id=B.volume_id       
  inner join project P on P.project_id = V.project_id  
where UQ.users_id=?

$ users by id select
select teams_id, user_name, last_name, first_name,
    unitize, uqc, coding, codingqc, qa, team_leader, admin,
    admin_users, admin_project, admin_batch, admin_edit, admin_import, admin_export, admin_profit
from users
where users_id = ?

$ users select
select last_name, first_name from users
where last_name = ? order by last_name, first_name

$ usersqueue delete
delete from usersqueue where batch_id = ? and users_id = ?

$ project and volume names
select P.project_name, V.volume_name
from project P inner join volume V using (project_id)
where V.volume_id=[volume]
